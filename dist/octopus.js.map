{"version":3,"sources":["node_modules/browser-pack/_prelude.js","components/namespace.js","components/rpcCommand.js","components/rpcEndpoint.js","components/rpcTransport.js","components/stockTransports.js","node_modules/debug-pest/index.js","octopus.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"octopus.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function () {\n\n\t/* ------\n\t\n\t\tCode below is adapted from the debug library, duly licensed as below.\n\n\t\t(The MIT License)\n\n\t\tCopyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy of this software\n\t\tand associated documentation files (the 'Software'), to deal in the Software without restriction,\n\t\tincluding without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t\tand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n\t\tsubject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all copies or substantial\n\t\tportions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT\n\t\tLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\t\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\t\tWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\t\tSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\t------ */\n\n\tvar Namespace = function (namespaces) {\n\n\t\tthis.names = [];\n\t\tthis.skips = [];\n\n\t\tvar i;\n\t\tvar split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tvar len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) continue; // ignore empty strings\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tthis.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tthis.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\n\t\treturn this;\n\t};\n\n\n\tNamespace.prototype.test = function (value) {\n\t\tvar i, len;\n\n\t\tfor (i = 0, len = this.skips.length; i < len; i++) {\n\t\t\tif (!this.skips[i].test(value))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, len = this.names.length; i < len; i++) {\n\t\t\tif (this.names[i].test(value))\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\n\tmodule.exports = Namespace;\n\n})();\n","(function () {\n\n\tconst Namespace = require('./namespace.js');\n\n\n\n\t/* ----------------------------------------------------------- */\n\n\n\tconst MESSAGETYPES = {\n\t\trequest: 'RQ',\n\t\tresponseAccept: 'RA',\n\t\tresponseFail: 'RF',\n\t\tresponseAcceptError: 'RAE',\n\t\tresponseFailError: 'RFE'\n\t};\n\n\n\tvar rpcCommand = function (name, endpoint, options) {\n\t\toptions = options || {};\n\t\t// console.log('Creating rpc command [%s] for endpoint [%s][%s]',name, endpoint.label, endpoint.dir);\n\t\tthis.name = name;\n\t\tthis.endpoint = endpoint;\n\t\tthis.requestHandlers = [];\n\t\tthis.responseHandlers = {};\n\t\tthis.onProvideFn = null;\n\t\tthis.endpoint.commands[name] = this;\n\n\t\tthis.logger = options.logger.child('CMD:' + this.name);\n\t\tthis.sendLogger = this.logger.child('send');\n\t\tthis.recvLogger = this.logger.child('recv');\n\t\tthis.logger.enabled && this.logger.log('Created new command as ', name);\n\n\t\tthis.MESSAGETYPES = MESSAGETYPES;\n\t\treturn this;\n\t};\n\n\n\trpcCommand.prototype.autoID = function () {\n\t\treturn Math.random().toString().substr(8) + '-' + Date.now();\n\t};\n\n\trpcCommand.prototype.sendToID = function (tid, msg, mode, pTransName) {\n\t\tvar _self = this;\n\n\t\tmsg.msgID = _self.autoID();\n\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n[sendToID] called with tid[%s], msgID[%s], mode[%s], pTransName[%s] \\n', tid, msg.msgID, mode, pTransName);\n\n\t\t/*\n\t\t\tNOTE - Adding a check as a hotfix to avoind crashing on tName errors.\n\n\t\t\tSource of errors - sendToID is called from call() as well as recursively, when responding to messages.\n\n\t\t\tThe source of tName errors may be the async nature. Since this is async, there's a gap in between call & execution\n\t\t\tbetween which a \"remove()\" function call might delete the transport, raising such issues.\n\n\t\t\tCase #1 - Deleted transport after a call from .call(), but before the execution of sendToID, causing tName errors.\n\t\t\tCase #2 - Alternately, Deleted the transport after a message was recieved, but before a response could be sent.\n\n\t\t\tNOTE - EDGE CASE TO SOLVE :\n\t\t\tWhat happens if in either case, the response is critical for proper function / avoiding duplication of calls (see below),\n\t\t\tand could be sent because the reciever still exists (ie same tName), but over a different transport (ie different tID).\n\n\t\t\tHow duplication of calls -\n\t\t\t\tSender sends RPC\n\t\t\t\tReciever gets RPC & executes provider\n\t\t\t\tSender disconnects & reconnects with a new connection\n\t\t\t\tReciever removes previous socket & re-adds new socket (ie same tName, once initial handshake is done, but different tID).\n\t\t\t\tReciever RPC call response fails / ignored because old tID doesn't exist anymore.\n\t\t\t\tSender times out (or considers failure due to disconnection / remains hanging as a memory leak), even though RPC provider has executed on reciever\n\t\t\t\tApplication tries again assuming bad RPC call.\n\n\t\t\tPossible solution -\n\t\t\t\tif tID mismatch is found,\n\t\t\t\t\ta search of other transports with the same tName is done,\n\t\t\t\t\t \tif found, send as usual and resolve\n\t\t\t\t\t\tif not found,\n\t\t\t\t\t\t\tcall is hooked and waits till another transport with the same name connects before timeout\n\t\t\t\t\t\t\tif connects,\n\t\t\t\t\t\t\t\tsend as usual & resolve\n\t\t\t\t\t\t\tif not,\n\t\t\t\t\t\t\t\tfail with a timeout\n\t\t*/\n\n\t\tif (!_self.endpoint.transports[tid]) {\n\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n[sendToID] transport to tid[%s] does not exist. Taking corrective action... \\n', tid);\n\n\n\t\t\tvar trans = _self.endpoint.findTransportByName(pTransName);\n\n\t\t\t// If found, continue with discovered transport\n\t\t\tif (trans) {\n\t\t\t\ttid = trans.id;\n\t\t\t}\n\n\t\t\t// Else wait for a new transport to connect, or reject on timeout\n\t\t\telse {\n\t\t\t\treturn Promise.resolve()\n\n\t\t\t\t\t// Wait for new transport with given name to setup\n\t\t\t\t\t.then(() => _self.endpoint.addTransportNameChangeHook(pTransName))\n\n\t\t\t\t\t// Call this recursively and try to resend\n\t\t\t\t\t.then((t) => this.sendToID(t.id, msg, mode, pTransName))\n\n\t\t\t\t\t// Reject if it fails (worst case situation)\n\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.warn('[ERROR] transport tName[%s] was not found as tid[%s]. Might lead to duplicated provider executions, if re-connections caused it.', tName, tid);\n\n\t\t\t\t\t\tif (!mode || mode != 'respond') {\n\t\t\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.warn('Cannot call - missing transport');\n\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\tsent: false,\n\t\t\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\t\t\ttransport: pTransName,\n\t\t\t\t\t\t\t\tcommand: _self.name,\n\t\t\t\t\t\t\t\tresponse: 'transport removed or changed'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.warn('Cannot respond - missing transport');\n\t\t\t\t\t\t\treturn Promise.reject('transport missing');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// NOTE - In case the tName has changed since the call\n\t\tvar tName = _self.endpoint.transports[tid].tName;\n\n\t\tmsg.source = _self.endpoint.label;\n\t\t_self.sendLogger.enabled && _self.sendLogger.log('Sending on transport [%s][%s], mode = %s,  msg =', tid, tName, mode, msg);\n\n\n\t\tif (!mode || mode != 'respond') {\n\n\t\t\treturn new Promise((res, rej) => {\n\n\t\t\t\tvar sent = false;\n\n\t\t\t\t// handler function\n\t\t\t\tvar handler = function (respData, msgType) {\n\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\nResponse handler called with respData & msgTypes as \\n', respData, msgType);\n\n\t\t\t\t\tdelete _self.responseHandlers[tName][msg.msgID];\n\n\n\t\t\t\t\tswitch (msgType) {\n\n\t\t\t\t\tcase MESSAGETYPES.responseAccept:\n\t\t\t\t\t\tres({\n\t\t\t\t\t\t\tsent: sent,\n\t\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\t\ttransport: tName,\n\t\t\t\t\t\t\tcommand: _self.name,\n\t\t\t\t\t\t\tresponse: respData\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MESSAGETYPES.responseFail:\n\t\t\t\t\t\tres({\n\t\t\t\t\t\t\tsent: sent,\n\t\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\t\ttransport: tName,\n\t\t\t\t\t\t\tcommand: _self.name,\n\t\t\t\t\t\t\tresponse: respData\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\n\t\t\t\tif (!_self.responseHandlers[tName])\n\t\t\t\t\t_self.responseHandlers[tName] = {};\n\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\nAdding response handler at [%s][%s] \\n', tName, msg.msgID);\n\t\t\t\t_self.responseHandlers[tName][msg.msgID] = handler;\n\n\n\t\t\t\tvar container = {\n\t\t\t\t\trpc_msg: {},\n\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t};\n\t\t\t\tcontainer.rpc_msg[_self.name] = msg;\n\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n\\nSending %s to [%s] as \\n', mode == 'respond' ? 'response' : 'request', tName, container);\n\t\t\t\tPromise.resolve(_self.endpoint.transports[tid].send(container))\n\t\t\t\t\t.then((s) => sent = true)\n\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\tsent = false;\n\t\t\t\t\t\thandler(e, MESSAGETYPES.responseFail);\n\t\t\t\t\t});\n\n\t\t\t});\n\t\t} else {\n\n\t\t\tvar container = {\n\t\t\t\trpc_msg: {},\n\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t};\n\t\t\tcontainer.rpc_msg[_self.name] = msg;\n\n\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n\\nSending %s to [%s] as \\n', mode == 'respond' ? 'response' : 'request', tName, container);\n\t\t\treturn Promise.resolve(_self.endpoint.transports[tid].send(container));\n\t\t}\n\t};\n\n\t/*\n\t\tData can be a value or a function.\n\t\tIf its a function, it will be evaluated for every new transport and passed the transport name & index as parameters.\n\t*/\n\trpcCommand.prototype.call = function (namespace, data, mode) {\n\t\tvar _self = this;\n\t\tvar tName;\n\t\tnamespace = new Namespace(namespace);\n\t\tvar tasks = [];\n\t\tvar evaluate = false;\n\n\t\tvar msg = {\n\t\t\tmsgID: _self.autoID(),\n\t\t\tmsgType: MESSAGETYPES.request,\n\t\t\treqData: data,\n\t\t};\n\n\t\tif (typeof data === 'function') {\n\t\t\tevaluate = true;\n\t\t}\n\n\n\t\tObject.keys(_self.endpoint.transports)\n\t\t\t.forEach(function (tid, index) {\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('Scanning for namespace on transport [%s] as \\n', tid);\n\n\t\t\t\ttName = _self.endpoint.transports[tid].tName;\n\n\t\t\t\tif (_self.endpoint.transports[tid].initialised === true && namespace.test(tName)) {\n\t\t\t\t\tif (evaluate === true)\n\t\t\t\t\t\tmsg.reqData = data(_self.endpoint.transports[tid].tName, index);\n\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('Transport [%s] is valid. Attempting to send', tid);\n\n\t\t\t\t\t// NOTE - adding tName at the end as identification in case of tName errors. See .sendToID() comments.\n\t\t\t\t\ttasks.push(_self.sendToID(tid, msg, mode, tName));\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (tasks.length > 0)\n\t\t\treturn Promise.all(tasks);\n\t\telse\n\t\t\treturn Promise.resolve([{\n\t\t\t\tsent: false,\n\t\t\t\tstatus: false,\n\t\t\t\ttransport: '',\n\t\t\t\tcommand: _self.name,\n\t\t\t\tresponse: 'no transports added'\n\t\t\t}]);\n\t};\n\n\t// rpcCommand.prototype.call = function (namespaceString, data) {\n\t// \tvar _self = this;\n\t//\n\t// \tvar msg = {\n\t// \t\tmsgID: _self.autoID(),\n\t// \t\tmsgType: MESSAGETYPES.request,\n\t// \t\treqData: data,\n\t// \t};\n\t//\n\t//\n\t// \t_self.sendLogger.enabled && _self.sendLogger.log('Requesting RPC with msg = ', msg);\n\t// \treturn _self.send(namespaceString, msg);\n\t//\n\t// };\n\n\n\trpcCommand.prototype.recieve = function (msg, transport) {\n\t\tvar _self = this;\n\t\tvar tName = transport.tName,\n\t\t\ttid = transport.id;\n\n\t\t_self.recvLogger.enabled && _self.recvLogger.log('\\n\\n\\nCommand [%s] Data recvd on [%s][%s] as \\n', _self.name, _self.endpoint.label, _self.endpoint.dir, tName, msg);\n\n\t\tswitch (msg.msgType) {\n\t\tcase MESSAGETYPES.responseAccept:\n\t\tcase MESSAGETYPES.responseFail:\n\t\t\t// console.log('\\n\\n\\nResponse recvd on [%s] from [%s] as\\n ',tName, msg.rtName, msg);\n\t\t\tif (_self.responseHandlers[tName] && _self.responseHandlers[tName][msg.respID]) {\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('handler found. Responding !');\n\t\t\t\treturn Promise.resolve(_self.responseHandlers[tName][msg.respID](msg.respData, msg.msgType));\n\n\t\t\t} else {\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('handler not found');\n\t\t\t\treturn Promise.reject(new Error('handler not found'));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MESSAGETYPES.request:\n\t\t\t// console .log('\\n\\nCommand[%s] Request recvd on [%s] as\\n ',_self.name, tName,msg);\n\n\t\t\tif (_self.requestHandlers.length > 0) {\n\t\t\t\t// console.log('\\n[%s]Request handlers found\\n ',_self.requestHandlers.length);\n\n\t\t\t\tvar chain = Promise.resolve();\n\t\t\t\tvar reqData = msg.reqData;\n\n\t\t\t\t_self.requestHandlers.forEach((h) => {\n\t\t\t\t\t/* Each handler is called with (v,p,s,t,msg) as follows\n\t\t\t\t\t\tv\t= reqData \t- data sent by caller,\n\t\t\t\t\t\tp\t= prev\t\t- response got from the prevhandler's execution for this call,\n\t\t\t\t\t\ts \t= msg.source \t- name of the calling transport (this was the actual usecase for tName ?)\n\t\t\t\t\t\tt\t= tName \t\t- name of current transport (TODO - buggy, points to local transport name)\n\t\t\t\t\t\tmsg \t= msg \t\t- full raw msg obj\n\t\t\t\t\t*/\n\t\t\t\t\tchain = chain.then((prev) => h(msg.reqData, prev, msg.source, tName, msg));\n\t\t\t\t});\n\t\t\t\treturn chain\n\t\t\t\t\t.then((respData) => {\n\t\t\t\t\t\t// console.log('\\nRequest handlers SUCCESS\\n Results are',respData);\n\n\t\t\t\t\t\tmsg.respID = msg.msgID;\n\t\t\t\t\t\tmsg.rtName = tName;\n\t\t\t\t\t\tmsg.msgID = _self.autoID();\n\t\t\t\t\t\tmsg.msgType = MESSAGETYPES.responseAccept;\n\t\t\t\t\t\tmsg.respData = respData;\n\t\t\t\t\t\tdelete msg.reqData;\n\t\t\t\t\t\treturn _self.sendToID(tid, msg, 'respond', tName);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t// console.log('\\nRequest handlers FAILED\\n Results are',e);\n\n\t\t\t\t\t\tmsg.respID = msg.msgID;\n\t\t\t\t\t\tmsg.rtName = tName;\n\t\t\t\t\t\tmsg.msgID = _self.autoID();\n\t\t\t\t\t\tmsg.msgType = MESSAGETYPES.responseFail;\n\t\t\t\t\t\tmsg.respData = e;\n\t\t\t\t\t\tdelete msg.reqData;\n\t\t\t\t\t\treturn _self.sendToID(tid, msg, 'respond', tName);\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => _self.onProvideFn ? _self.onProvideFn(reqData, msg.respData, tName, msg) : null)\n\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\tconsole.error('[Octopus] Error while executing [%s] provider chain on [%s] - ', _self.name, tName, e);\n\t\t\t\t\t\treturn Promise.reject(e);\n\t\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\t_self.recvLogger.enabled && _self.recvLogger.error('ERROR - No requestHandlers for command[%s] on [%s][%s] -  tName, msg - ', _self.name, _self.endpoint.label, _self.endpoint.dir, tName, msg);\n\t\t\t\tmsg.respID = msg.msgID;\n\t\t\t\tmsg.rtName = tName;\n\t\t\t\tmsg.msgID = _self.autoID();\n\t\t\t\tmsg.msgType = MESSAGETYPES.responseFail;\n\t\t\t\tmsg.respData = 'no providers';\n\t\t\t\tdelete msg.reqData;\n\t\t\t\treturn _self.sendToID(tid, msg, 'respond', tName);\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t};\n\n\trpcCommand.prototype.provide = function (fn) {\n\t\tif (typeof fn == \"function\")\n\t\t\tthis.requestHandlers.push(fn);\n\t\telse {\n\t\t\tthrow new Error('Param passed to \"provide\" is not a function');\n\t\t}\n\t};\n\n\trpcCommand.prototype.unProvide = function (fn) {\n\t\tvar index = this.requestHandlers.findIndex((x) => x === fn);\n\t\tif (index > -1)\n\t\t\tthis.requestHandlers.splice(index, 1);\n\t\treturn this;\n\t};\n\n\t/*\n\t\tExecutes passed fn when provide response is successfully recieved by remote.\n\t\t\tAssuming transport send() function returns a promise on successfull\n\t\t\ttransfer of response message\n\t*/\n\trpcCommand.prototype.onProvide = function (fn) {\n\t\tif (typeof fn == \"function\")\n\t\t\tthis.onProvideFn = fn;\n\t\telse {\n\t\t\tthrow new Error('Param passed to \"onProvideFn\" is not a function');\n\t\t}\n\t};\n\n\n\n\t/* ----------------------------------------------------------- */\n\n\n\tmodule.exports = rpcCommand;\n\n})();\n","(function () {\n\n\tconst Namespace = require('./namespace.js');\n\tconst rpcStockTransports = require('./stockTransports.js');\n\tconst rpcTransport = require('./rpcTransport.js');\n\tconst rpcCommand = require('./rpcCommand.js');\n\t/* ----------------------------------------------------------- */\n\n\n\tvar rpcEndpoint = function (l, dir, options) {\n\t\toptions = options || {};\n\t\tthis.logger = options.logger.child(dir == 'i' ? 'EP:in' : 'EP:out');\n\n\n\t\tthis.transports = {};\n\t\tthis.nameChangeHooks = {};\n\t\tthis.label = l;\n\t\tthis.dir = dir;\n\t\tthis.commands = {};\n\t\tthis.transportTypes = rpcStockTransports;\n\n\t\tthis.logger.enabled && this.logger.log('Created new endpoint as [%s][%s]', l, dir);\n\n\t\treturn this;\n\t};\n\n\trpcEndpoint.prototype.pluginTransports = function (tColl) {\n\t\tthis.transportTypes = Object.assign(this.transportTypes, tColl);\n\t};\n\n\trpcEndpoint.prototype.over = function (socket, type) {\n\t\treturn new rpcTransport(type, socket, this, { logger: this.logger });\n\t};\n\trpcEndpoint.prototype.remove = function (socket) {\n\t\tvar _self = this;\n\t\t// Object.keys(_self.transports).forEach((tid) => {\n\t\t// \tif (_self.transports[tid].socket == socket){\n\t\t// \t\t_self.logger.enabled && _self.logger.log('Destroying & removing transport [%s] tName [%s]. ',tid,_self.transports[tid].tName);\n\t\t// \t\t_self.transports[tid].destroy();\n\t\t// \t\tdelete _self.transports[tid];\n\t\t// \t}\n\t\t// });\n\n\t\t// _self.logger.enabled && _self.logger.log('Attempting to remove socket. ',socket._octopus);\n\t\t// _self.logger.enabled && _self.logger.log('Current endpoint[%s][%s] transports are . ',_self.label, _self.dir, _self.transports);\n\n\t\tif (socket && socket._octopus && socket._octopus.transports) {\n\n\t\t\t// Go through transports added to socket\n\t\t\tsocket._octopus.transports.forEach((t) => {\n\n\t\t\t\t// See if its a transport of this endpoint\n\t\t\t\tvar foundT = Object.keys(_self.transports).find(x => _self.transports[x] === t);\n\n\t\t\t\t// if found, disassociate from socket, destroy and delete from endpoint\n\t\t\t\tif (foundT) {\n\t\t\t\t\tfoundT = _self.transports[foundT];\n\t\t\t\t\t_self.logger.enabled && _self.logger.warn('Destroying & removing transport [%s] tName [%s] from endpoint[%s][%s]. ', foundT.id, foundT.tName, _self.label, _self.dir);\n\n\t\t\t\t\tvar index = socket._octopus.transports.findIndex(x => x == t);\n\t\t\t\t\tsocket._octopus.transports.splice(index, 1);\n\n\n\t\t\t\t\tfoundT.destroy();\n\t\t\t\t\tdelete _self.transports[foundT.id];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\trpcEndpoint.prototype.rename = function (namespace) {\n\n\t\t/*\n\t\t\tNOTE - Must investigate if there are side effects ?\n\n\t\t\tShould we be allowed to change remote side name ?\n\t\t\t\tAny usecase where we need it ?\n\n\t\t\tIf our name change is accepted by remote side,\n\t\t\t \tshould it trigger name changes with other connected transports too ? since there can only be one name for the remote.\n\n\t\t\tIf we change the remote's name,\n\t\t\t\tshould it trigger name changes with other connected transports too ? since there can only be one name for the remote.\n\n\t\t\tIf so,\n\t\t\t\tCould this cause infinite loops / ripples ?\n\n\t\t\tFor eg - Say connection path is setup as\n\t\t\t\tA - B - C - D - A\n\t\t\t\t    |_______|\n\n\t\t*/\n\t\tvar _self = this;\n\t\tnamespace = new Namespace(namespace);\n\t\treturn {\n\t\t\tas: (newName) => {\n\t\t\t\t_self.label = newName;\n\t\t\t\tObject.keys(_self.transports).forEach((tid) => {\n\t\t\t\t\tif (namespace.test(_self.transports[tid].tName)) {\n\t\t\t\t\t\t_self.transports[tid].as(newName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Internal hook called by transport, to signal a name change\n\trpcEndpoint.prototype.transportNameChanged = function (transport) {\n\n\t\t// Run past all registered hooks & see if any are registered for this tName\n\t\tif (this.nameChangeHooks[transport.tName]) {\n\t\t\tthis.nameChangeHooks[transport.tName].forEach(x => x(transport));\n\t\t}\n\t};\n\n\t/*\n\t\tReturns a one-time hook promise that\n\t\t\t1> resolves when appropriate name change occurs\n\t\t\t2> rejects if timeout happens\n\n\t\t& Automatically cleans up after it executes once (resolve or reject).\n\t*/\n\trpcEndpoint.prototype.addTransportNameChangeHook = function (tName, timeout) {\n\t\tif (!this.nameChangeHooks[tName])\n\t\t\tthis.nameChangeHooks[tName] = [];\n\n\t\tvar p = new Promise((res, rej) => {\n\t\t\tvar fn = (transport) => {\n\t\t\t\tif (res && !p.done) {\n\t\t\t\t\tp.done = true;\n\t\t\t\t\tvar i = this.nameChangeHooks[tName].findIndex(x => x == fn);\n\t\t\t\t\tthis.nameChangeHooks[tName].splice(i, 1);\n\t\t\t\t\tres(transport);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.nameChangeHooks[tName].push(fn);\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (rej && !p.done) {\n\t\t\t\t\tp.done == true;\n\t\t\t\t\tvar i = this.nameChangeHooks[tName].findIndex(x => x == fn);\n\t\t\t\t\tthis.nameChangeHooks[tName].splice(i, 1);\n\t\t\t\t\trej();\n\t\t\t\t}\n\t\t\t}, timeout || 5000);\n\n\t\t});\n\n\t\treturn p;\n\t};\n\n\trpcEndpoint.prototype.displayString = function () {\n\t\tvar _self = this;\n\t\tvar logString = 'key\\t\\t\\tname\\t\\t\\ttype:id\\t\\t\\tinitalised\\n';\n\t\tObject.keys(_self.transports).forEach((tKey) => {\n\t\t\tlogString += `${tKey}\\t\\t${_self.transports[tKey].tName}\\t\\t${_self.transports[tKey].type +':'+_self.transports[tKey].id}\\t\\t${_self.transports[tKey].initialised}\\n`;\n\t\t});\n\t\treturn logString;\n\t};\n\n\trpcEndpoint.prototype.command = function (name) {\n\t\treturn new rpcCommand(name, this, { logger: this.logger });\n\t};\n\n\trpcEndpoint.prototype.findTransportByName = function (tName) {\n\t\tvar tKey = Object.keys(this.transports).find(x => this.transports[x].tName == tName);\n\n\t\tif (tKey)\n\t\t\treturn this.transports[tKey];\n\t\telse\n\t\t\treturn null;\n\t};\n\n\t/* ----------------------------------------------------------- */\n\n\n\tmodule.exports = rpcEndpoint;\n\n})();\n","(function () {\n\tvar idCount = 0;\n\tvar autoID = function () {\n\t\treturn 'T' + (++idCount);\n\t};\n\n\tvar rpcTransport = function (type, socket, endpoint, options) {\n\t\t// console.log('Creating rpc transport [%s] for endpoint [%s][%s]',type, endpoint.label, endpoint.dir);\n\t\toptions = options || {};\n\t\tvar _self = this;\n\n\t\t_self.id = autoID();\n\t\t_self.logger = options.logger.child('T:' + type + ':' + _self.id);\n\n\t\t_self.endpoint = endpoint;\n\t\t_self.type = type;\n\t\t_self.socket = socket; // Also used for matching & removal, besides internal socket access.\n\t\t_self.tName = 'nonname';\n\t\t_self.initialised = false;\n\t\t_self.disabled = false;\n\t\t_self.nameClock = 0;\n\t\t_self.dirFlip = {\n\t\t\ti: 'o',\n\t\t\to: 'i'\n\t\t};\n\n\t\t// Add trasport type specific methods to self\n\t\tObject.assign(_self, _self.endpoint.transportTypes[type](type, socket));\n\t\tif(!socket._octopus)\n\t\t\tsocket._octopus = {};\n\n\t\tif(!socket._octopus.transports)\n\t\t\tsocket._octopus.transports = [];\n\n\t\tif(!socket._octopus.transports.includes(this))\n\t\t\tsocket._octopus.transports.push(this);\n\n\t\t_self.initPromise = new Promise((res, rej) => {\n\t\t\t_self.recvHandler = function (data) {\n\n\t\t\t\t// Abort if we're disabled\n\t\t\t\tif(_self.disabled)\n\t\t\t\t\treturn;\n\n\n\t\t\t\t// _self.logger.enabled && _self.logger.log('[onRecv] Data recvd on [%s][%s]',_self.tName,_self.endpoint.dir, data);\n\t\t\t\tif (data.rpc_dir == _self.dirFlip[_self.endpoint.dir]) {\n\t\t\t\t\t// console.log('[onRecv] Data accepted on [%s][%s]',_self.tName,_self.endpoint.dir, data);\n\n\t\t\t\t\tif (data.rpc_tName_change) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tNOTE - Implementing \"Latest & last write wins\" consensus policy :\n\t\t\t\t\t\t\t\tWHY ? - Required to solve disputes when both(or more) endpoints request a name change at the same time.\n\t\t\t\t\t\t\t\tWithout this, a simultaneous request causes each one to sends his name change over while implementing the other's name change request.\n\t\t\t\t\t\t\t\t \tconsequence - a name swap, instead of consensus on a single name value.\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tif(data.rpc_tName_change.request == true){\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOpposite party has requested a name change transaction, to be initiated from here.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('Name change requested by remote. Initiating transaction...',_self.tName);\n\n\t\t\t\t\t\t\t_self.as(_self.tName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (data.rpc_tName_change.ack == true) {\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOpposite party has accepted the name change that we proposed.\n\t\t\t\t\t\t\t\tHurray. Signal namechange to endpoint & resolve.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('Name change to [%s] acknowledged.',_self.tName);\n\n\t\t\t\t\t\t\t_self.endpoint.transportNameChanged(_self);\n\n\t\t\t\t\t\t\tif (!_self.initialised) {\n\t\t\t\t\t\t\t\t_self.initialised = true;\n\t\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('changed initialised status from false to true');\n\t\t\t\t\t\t\t\tres();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (data.rpc_tName_change.force || data.rpc_tName_change.clock >= _self.nameClock) {\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOpposite party's clock is higher or has already reached the same level (ie before us).\n\t\t\t\t\t\t\t\tAccept their proposal, send ack, signal namechange to endpoint\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('[%s, clock %s] [%s] Changing name of transport [%s][%s] to [%s] at clock =', _self.endpoint.label, _self.nameClock, data.rpc_tName_change.force ? 'forced' : '', _self.tName, _self.id, data.rpc_tName_change.tName, data.rpc_tName_change.clock);\n\t\t\t\t\t\t\t// delete _self.endpoint.transports[_self.tName];\n\t\t\t\t\t\t\t_self.tName = data.rpc_tName_change.tName;\n\t\t\t\t\t\t\t_self.nameClock = data.rpc_tName_change.clock;\n\t\t\t\t\t\t\t// _self.endpoint.transports[_self.tName] = _self;\n\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('Name change to [%s] accepted.',_self.tName);\n\n\t\t\t\t\t\t\t// Send ack\n\t\t\t\t\t\t\t_self.send({\n\t\t\t\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\t\t\t\ttName: _self.tName,\n\t\t\t\t\t\t\t\t\tclock: _self.nameClock,\n\t\t\t\t\t\t\t\t\tack: true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t_self.endpoint.transportNameChanged(_self);\n\n\t\t\t\t\t\t\tif (!_self.initialised) {\n\t\t\t\t\t\t\t\t_self.initialised = true;\n\t\t\t\t\t\t\t\tres();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOur clock is higher, so don't accept.\n\t\t\t\t\t\t\t\tPropose our name instead.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('[%s, clock %s] [%s] Rejecting name change of transport [%s][%s] as [%s] at clock =', _self.endpoint.label, _self.nameClock, data.rpc_tName_change.force ? 'forced' : '', _self.tName, _self.id, data.rpc_tName_change.tName, data.rpc_tName_change.clock);\n\t\t\t\t\t\t\t_self.send({\n\t\t\t\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\t\t\t\ttName: _self.tName,\n\t\t\t\t\t\t\t\t\tclock: _self.nameClock,\n\t\t\t\t\t\t\t\t\tforce: true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.rpc_msg) {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tObject.keys(data.rpc_msg).forEach((cKey) => {\n\n\t\t\t\t\t\t\tif (_self.endpoint.commands[cKey]){\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t// _self.logger.enabled && _self.logger.log('[onRecv] Data recvd on [%s][%s]',_self.tName,_self.endpoint.dir, data);\n\t\t\t\t\t\t\t\t_self.endpoint.commands[cKey].recieve(data.rpc_msg[cKey], _self)\n\t\t\t\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.error('[%s] Failed to respond to [%s] request (registered) from [%s] because -  ', _self.endpoint.label, cKey, _self.tName);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t// Create a temp command and process.\n\t\t\t\t\t\t\t\t_self.endpoint.command(cKey).recieve(data.rpc_msg[cKey], _self)\n\t\t\t\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.error('[%s] Failed to respond to [%s] request (temporary) from [%s] because -  ', _self.endpoint.label, cKey, _self.tName);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t_self.onRecv(_self.recvHandler);\n\n\t\t\t_self.destroy = function(){\n\t\t\t\t// _self.logger.enabled && _self.logger.log('[%s] Destroying transport [%s] =', _self.endpoint.label, _self.tName);\n\t\t\t\t_self.disabled = true;\n\t\t\t\t_self.socket = null;\n\n\t\t\t\tif(_self.stopRecv){\n\t\t\t\t\t// _self.logger.enabled && _self.logger.log('[%s] Destroying transport [%s] - stopRecv found =', _self.endpoint.label, _self.tName);\n\t\t\t\t\t_self.stopRecv(_self.recvHandler);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t_self.as = function (tName) {\n\t\t\t\t// delete _self.endpoint.transports[_self.tName];\n\t\t\t\tvar prevName = _self.tName;\n\t\t\t\t_self.tName = tName;\n\t\t\t\t_self.nameClock++;\n\t\t\t\t_self.logger.enabled && _self.logger.log('[%s] Sending namechange of transport [%s][%s] to [%s] at clock =', _self.endpoint.label, prevName, tName, _self.id, _self.nameClock);\n\t\t\t\t_self.send({\n\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\ttName: _self.tName,\n\t\t\t\t\t\tclock: _self.nameClock\n\t\t\t\t\t},\n\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t});\n\t\t\t\t// // _self.endpoint.transports[tName] = _self;\n\t\t\t\t// if(!_self.initialised) {\n\t\t\t\t// \t_self.initialised = true;\n\t\t\t\t// \tres();\n\t\t\t\t// }\n\t\t\t\treturn _self;\n\t\t\t};\n\n\t\t\t// Triggers an '.as()' function on the remote end of the socket.\n\t\t\t_self.asRemote = function(){\n\t\t\t\t_self.logger.enabled && _self.logger.log('Requesting namechange from remote, at clock =', _self.nameClock);\n\t\t\t\t_self.send({\n\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\trequest:true\n\t\t\t\t\t},\n\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t});\n\n\t\t\t\treturn _self;\n\t\t\t};\n\t\t});\n\n\t\t_self.endpoint.transports[_self.id] = _self;\n\t\t_self.logger.enabled && _self.logger.log('Added transport [%s][%s] for endpoint [%s][%s]', type, _self.id, endpoint.label, endpoint.dir);\n\t\treturn _self;\n\t};\n\n\t/* ----------------------------------------------------------- */\n\n\n\tmodule.exports = rpcTransport;\n\n})();\n","(function () {\n\n\tvar transportTypes = {};\n\n\ttransportTypes['socketio'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.send(JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['websocket'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => {\n\t\t\t\treturn new Promise((res, rej) => {\n\t\t\t\t\tsocket.send(\n\t\t\t\t\t\tJSON.stringify(data),\n\t\t\t\t\t\t(e) => e ? rej(e) : res()\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['processLocal'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.emit('message', JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['nodeEELocal'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.emit('message', JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['processRemote'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => {\n\t\t\t\treturn new Promise((res, rej) => {\n\t\t\t\t\tvar s = socket.send(\n\t\t\t\t\t\tJSON.stringify(data),\n\t\t\t\t\t\t(e) => e instanceof Error ? rej(e) : (s === true ? res(s) : rej(s))\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['nodeEERemote'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.send('message', JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\n\tmodule.exports = transportTypes;\n\n})();\n","module.exports = function(debug){\n\n\tvar logger = function (suffix) {\n\t\tthis.enabled = false;\n\t\tthis.prefix = suffix || '';\n\n\t\tif(typeof debug == 'function'){\n\t\t\tthis.log = debug(`logs:` + this.prefix);\n\t\t\tthis.warn = debug(`warnings:` + this.prefix);\n\t\t\tthis.error = debug(`errors:` + this.prefix);\n\t\t\tthis.enabled = true;\n\t\t}\n\t\telse{\n\t\t\tthis.log = ()=>{};\n\t\t\tthis.warn = ()=>{};\n\t\t\tthis.error = ()=>{};\n\t\t\tthis.enabled = false;\n\t\t}\n\t};\n\n\tlogger.prototype.child = function (suffix) {\n\t\treturn new logger(this.prefix + ':' + suffix);\n\t};\n\n\treturn logger;\n};\n","module.exports = function (debug) {\n\n\tconst Namespace = require('./components/namespace.js');\n\tconst rpcEndpoint = require('./components/rpcEndpoint.js');\n\tconst debugr = require('debug-pest')(debug);\n\tvar appLogger = new debugr('octopus');\n\n\t/* ----------------------------------------------------------- */\n\n\tvar rpcs = {};\n\n\tvar rpc = function (name, options) {\n\t\toptions = options || {};\n\n\n\t\tif (options.create === true) {\n\t\t\tthis.name = name;\n\t\t\tthis.commands = {};\n\t\t\tthis.logger = appLogger.child(this.name);\n\n\t\t\tthis.incoming = new rpcEndpoint(name, 'i', { logger: this.logger });\n\t\t\tthis.outgoing = new rpcEndpoint(name, 'o', { logger: this.logger });\n\n\t\t\tthis.logger.enabled && this.logger.log('Created new Octopus RPC as ', this.name);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!rpcs[name]) {\n\t\t\toptions.create = true;\n\t\t\trpcs[name] = new rpc(name, options);\n\t\t}\n\n\n\t\treturn rpcs[name];\n\n\t};\n\trpc.prototype.displayTransports = function () {\n\t\t// console.log('\\n\\n\\n------ Transports for [%s] are:\\n', this.name);\n\t\t// console.log('incoming:\\n');\n\t\t// this.incoming.displayTransports();\n\t\t// console.log('\\n\\noutgoing:\\n');\n\t\t// this.outgoing.displayTransports();\n\t\t// console.log('\\n--------------------------\\n\\n');\n\n\t\tvar logString = `\n\n-------------------- TRANSPORTS for [${this.name}] are : ---------------------------\n\nIncoming (provides):\n\n`;\n\n\t\tlogString += this.incoming.displayString();\n\t\tlogString += `\\n\\n-------------\\nOutgoing (calls):\\n\\n`;\n\t\tlogString += this.outgoing.displayString();\n\t\tlogString += '\\n\\n------------------------------------------------------------------------------------\\n\\n';\n\n\t\tconsole.log(logString);\n\t};\n\n\trpc.prototype.over = function (socket, type) {\n\t\tvar tasks = [];\n\t\ttasks.push(\n\t\t\tthis.incoming.over(socket, type)\n\t\t\t.as(this.name)\n\t\t\t.initPromise\n\t\t);\n\t\ttasks.push(\n\t\t\tthis.outgoing.over(socket, type)\n\t\t\t.asRemote()\n\t\t\t.initPromise\n\t\t);\n\t\treturn Promise.all(tasks);\n\t};\n\trpc.prototype.remove = function (socket) {\n\t\tthis.incoming.remove(socket);\n\t\tthis.outgoing.remove(socket);\n\t};\n\n\trpc.prototype.pluginTransports = function (tObj) {\n\t\tthis.incoming.pluginTransports(tObj);\n\t\tthis.outgoing.pluginTransports(tObj);\n\t};\n\trpc.prototype.command = function (name) {\n\t\tvar _self = this;\n\t\tif (!_self.commands[name]) {\n\t\t\tvar iC = _self.incoming.command(name);\n\t\t\tvar oC = _self.outgoing.command(name);\n\t\t\t_self.MESSAGETYPES = iC.MESSAGETYPES || oC.MESSAGETYPES;\n\n\t\t\t_self.commands[name] = {\n\t\t\t\tprovide: function (fn) {\n\t\t\t\t\tiC.provide(fn);\n\t\t\t\t\treturn _self.commands[name];\n\t\t\t\t},\n\t\t\t\tunProvide: function (fn) {\n\t\t\t\t\tiC.unProvide(fn);\n\t\t\t\t\treturn _self.commands[name];\n\t\t\t\t},\n\t\t\t\tonProvide: function (fn) {\n\t\t\t\t\tiC.onProvide(fn);\n\t\t\t\t\treturn _self.commands[name];\n\t\t\t\t},\n\t\t\t\tcall: function (filter, data) {\n\t\t\t\t\t// _self.displayTransports();\n\t\t\t\t\treturn oC.call(filter, data);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn this.commands[name];\n\t};\n\trpc.prototype.renameTo = function (newName) {\n\t\tthis.incoming.rename(this.name)\n\t\t\t.as(newName);\n\t\tthis.name = newName;\n\t\t// this.outgoing.label = newName;\n\t\treturn this;\n\t};\n\n\n\t/* ----------------  Result parsing & Resolving to Promise resolve/reject -----------*/\n\n\trpc.prototype.parseByStatus = function (res) {\n\t\tvar valids = [],\n\t\t\tinvalids = [],\n\t\t\tcheck;\n\t\tfor (var i = 0; i < res.length; i++) {\n\t\t\tcheck = res[i];\n\t\t\tif (check.sent === true && check.status === true)\n\t\t\t\tvalids.push(check);\n\t\t\telse\n\t\t\t\tinvalids.push(check);\n\t\t}\n\t\treturn {\n\t\t\tvalids: valids,\n\t\t\tinvalids: invalids\n\t\t};\n\t};\n\n\trpc.prototype.resolve = function (p) {\n\t\tif (p.sent === true && p.status === true)\n\t\t\treturn Promise.resolve(p.response);\n\t\telse\n\t\t\treturn Promise.reject(p.response);\n\t};\n\trpc.prototype.resolveAll = function (p) {\n\n\t\tfor (var i = 0; i < p.length; i++) {\n\t\t\tif (p[i].sent === false || p[i].status === false)\n\t\t\t\treturn Promise.reject(p);\n\t\t}\n\n\t\treturn Promise.resolve(p);\n\t};\n\trpc.prototype.resolveAtLeastOne = function (p) {\n\n\t\tfor (var i = 0; i < p.length; i++) {\n\t\t\tif (p[i].sent === true && p[i].status === true)\n\t\t\t\treturn Promise.resolve(p);\n\t\t}\n\n\t\treturn Promise.reject(p);\n\t};\n\n\n\n\n\treturn rpc;\n\n};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL25hbWVzcGFjZS5qcyIsImNvbXBvbmVudHMvcnBjQ29tbWFuZC5qcyIsImNvbXBvbmVudHMvcnBjRW5kcG9pbnQuanMiLCJjb21wb25lbnRzL3JwY1RyYW5zcG9ydC5qcyIsImNvbXBvbmVudHMvc3RvY2tUcmFuc3BvcnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnLXBlc3QvaW5kZXguanMiLCJvY3RvcHVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIoZnVuY3Rpb24gKCkge1xuXG5cdC8qIC0tLS0tLVxuXHRcblx0XHRDb2RlIGJlbG93IGlzIGFkYXB0ZWQgZnJvbSB0aGUgZGVidWcgbGlicmFyeSwgZHVseSBsaWNlbnNlZCBhcyBiZWxvdy5cblxuXHRcdChUaGUgTUlUIExpY2Vuc2UpXG5cblx0XHRDb3B5cmlnaHQgKGMpIDIwMTQgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cblxuXHRcdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZVxuXHRcdGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcblx0XHRpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuXHRcdGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG5cdFx0c3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0XHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG5cdFx0cG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1Rcblx0XHRMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cblx0XHRJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG5cdFx0V0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5cdFx0U09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblx0LS0tLS0tICovXG5cblx0dmFyIE5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2VzKSB7XG5cblx0XHR0aGlzLm5hbWVzID0gW107XG5cdFx0dGhpcy5za2lwcyA9IFtdO1xuXG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHR2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHR0aGlzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHROYW1lc3BhY2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR2YXIgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCF0aGlzLnNraXBzW2ldLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKHRoaXMubmFtZXNbaV0udGVzdCh2YWx1ZSkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vbmFtZXNwYWNlLmpzJyk7XG5cblxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXHRjb25zdCBNRVNTQUdFVFlQRVMgPSB7XG5cdFx0cmVxdWVzdDogJ1JRJyxcblx0XHRyZXNwb25zZUFjY2VwdDogJ1JBJyxcblx0XHRyZXNwb25zZUZhaWw6ICdSRicsXG5cdFx0cmVzcG9uc2VBY2NlcHRFcnJvcjogJ1JBRScsXG5cdFx0cmVzcG9uc2VGYWlsRXJyb3I6ICdSRkUnXG5cdH07XG5cblxuXHR2YXIgcnBjQ29tbWFuZCA9IGZ1bmN0aW9uIChuYW1lLCBlbmRwb2ludCwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdC8vIGNvbnNvbGUubG9nKCdDcmVhdGluZyBycGMgY29tbWFuZCBbJXNdIGZvciBlbmRwb2ludCBbJXNdWyVzXScsbmFtZSwgZW5kcG9pbnQubGFiZWwsIGVuZHBvaW50LmRpcik7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG5cdFx0dGhpcy5yZXF1ZXN0SGFuZGxlcnMgPSBbXTtcblx0XHR0aGlzLnJlc3BvbnNlSGFuZGxlcnMgPSB7fTtcblx0XHR0aGlzLm9uUHJvdmlkZUZuID0gbnVsbDtcblx0XHR0aGlzLmVuZHBvaW50LmNvbW1hbmRzW25hbWVdID0gdGhpcztcblxuXHRcdHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIuY2hpbGQoJ0NNRDonICsgdGhpcy5uYW1lKTtcblx0XHR0aGlzLnNlbmRMb2dnZXIgPSB0aGlzLmxvZ2dlci5jaGlsZCgnc2VuZCcpO1xuXHRcdHRoaXMucmVjdkxvZ2dlciA9IHRoaXMubG9nZ2VyLmNoaWxkKCdyZWN2Jyk7XG5cdFx0dGhpcy5sb2dnZXIuZW5hYmxlZCAmJiB0aGlzLmxvZ2dlci5sb2coJ0NyZWF0ZWQgbmV3IGNvbW1hbmQgYXMgJywgbmFtZSk7XG5cblx0XHR0aGlzLk1FU1NBR0VUWVBFUyA9IE1FU1NBR0VUWVBFUztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXG5cdHJwY0NvbW1hbmQucHJvdG90eXBlLmF1dG9JRCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cig4KSArICctJyArIERhdGUubm93KCk7XG5cdH07XG5cblx0cnBjQ29tbWFuZC5wcm90b3R5cGUuc2VuZFRvSUQgPSBmdW5jdGlvbiAodGlkLCBtc2csIG1vZGUsIHBUcmFuc05hbWUpIHtcblx0XHR2YXIgX3NlbGYgPSB0aGlzO1xuXG5cdFx0bXNnLm1zZ0lEID0gX3NlbGYuYXV0b0lEKCk7XG5cdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdcXG5cXG5bc2VuZFRvSURdIGNhbGxlZCB3aXRoIHRpZFslc10sIG1zZ0lEWyVzXSwgbW9kZVslc10sIHBUcmFuc05hbWVbJXNdIFxcbicsIHRpZCwgbXNnLm1zZ0lELCBtb2RlLCBwVHJhbnNOYW1lKTtcblxuXHRcdC8qXG5cdFx0XHROT1RFIC0gQWRkaW5nIGEgY2hlY2sgYXMgYSBob3RmaXggdG8gYXZvaW5kIGNyYXNoaW5nIG9uIHROYW1lIGVycm9ycy5cblxuXHRcdFx0U291cmNlIG9mIGVycm9ycyAtIHNlbmRUb0lEIGlzIGNhbGxlZCBmcm9tIGNhbGwoKSBhcyB3ZWxsIGFzIHJlY3Vyc2l2ZWx5LCB3aGVuIHJlc3BvbmRpbmcgdG8gbWVzc2FnZXMuXG5cblx0XHRcdFRoZSBzb3VyY2Ugb2YgdE5hbWUgZXJyb3JzIG1heSBiZSB0aGUgYXN5bmMgbmF0dXJlLiBTaW5jZSB0aGlzIGlzIGFzeW5jLCB0aGVyZSdzIGEgZ2FwIGluIGJldHdlZW4gY2FsbCAmIGV4ZWN1dGlvblxuXHRcdFx0YmV0d2VlbiB3aGljaCBhIFwicmVtb3ZlKClcIiBmdW5jdGlvbiBjYWxsIG1pZ2h0IGRlbGV0ZSB0aGUgdHJhbnNwb3J0LCByYWlzaW5nIHN1Y2ggaXNzdWVzLlxuXG5cdFx0XHRDYXNlICMxIC0gRGVsZXRlZCB0cmFuc3BvcnQgYWZ0ZXIgYSBjYWxsIGZyb20gLmNhbGwoKSwgYnV0IGJlZm9yZSB0aGUgZXhlY3V0aW9uIG9mIHNlbmRUb0lELCBjYXVzaW5nIHROYW1lIGVycm9ycy5cblx0XHRcdENhc2UgIzIgLSBBbHRlcm5hdGVseSwgRGVsZXRlZCB0aGUgdHJhbnNwb3J0IGFmdGVyIGEgbWVzc2FnZSB3YXMgcmVjaWV2ZWQsIGJ1dCBiZWZvcmUgYSByZXNwb25zZSBjb3VsZCBiZSBzZW50LlxuXG5cdFx0XHROT1RFIC0gRURHRSBDQVNFIFRPIFNPTFZFIDpcblx0XHRcdFdoYXQgaGFwcGVucyBpZiBpbiBlaXRoZXIgY2FzZSwgdGhlIHJlc3BvbnNlIGlzIGNyaXRpY2FsIGZvciBwcm9wZXIgZnVuY3Rpb24gLyBhdm9pZGluZyBkdXBsaWNhdGlvbiBvZiBjYWxscyAoc2VlIGJlbG93KSxcblx0XHRcdGFuZCBjb3VsZCBiZSBzZW50IGJlY2F1c2UgdGhlIHJlY2lldmVyIHN0aWxsIGV4aXN0cyAoaWUgc2FtZSB0TmFtZSksIGJ1dCBvdmVyIGEgZGlmZmVyZW50IHRyYW5zcG9ydCAoaWUgZGlmZmVyZW50IHRJRCkuXG5cblx0XHRcdEhvdyBkdXBsaWNhdGlvbiBvZiBjYWxscyAtXG5cdFx0XHRcdFNlbmRlciBzZW5kcyBSUENcblx0XHRcdFx0UmVjaWV2ZXIgZ2V0cyBSUEMgJiBleGVjdXRlcyBwcm92aWRlclxuXHRcdFx0XHRTZW5kZXIgZGlzY29ubmVjdHMgJiByZWNvbm5lY3RzIHdpdGggYSBuZXcgY29ubmVjdGlvblxuXHRcdFx0XHRSZWNpZXZlciByZW1vdmVzIHByZXZpb3VzIHNvY2tldCAmIHJlLWFkZHMgbmV3IHNvY2tldCAoaWUgc2FtZSB0TmFtZSwgb25jZSBpbml0aWFsIGhhbmRzaGFrZSBpcyBkb25lLCBidXQgZGlmZmVyZW50IHRJRCkuXG5cdFx0XHRcdFJlY2lldmVyIFJQQyBjYWxsIHJlc3BvbnNlIGZhaWxzIC8gaWdub3JlZCBiZWNhdXNlIG9sZCB0SUQgZG9lc24ndCBleGlzdCBhbnltb3JlLlxuXHRcdFx0XHRTZW5kZXIgdGltZXMgb3V0IChvciBjb25zaWRlcnMgZmFpbHVyZSBkdWUgdG8gZGlzY29ubmVjdGlvbiAvIHJlbWFpbnMgaGFuZ2luZyBhcyBhIG1lbW9yeSBsZWFrKSwgZXZlbiB0aG91Z2ggUlBDIHByb3ZpZGVyIGhhcyBleGVjdXRlZCBvbiByZWNpZXZlclxuXHRcdFx0XHRBcHBsaWNhdGlvbiB0cmllcyBhZ2FpbiBhc3N1bWluZyBiYWQgUlBDIGNhbGwuXG5cblx0XHRcdFBvc3NpYmxlIHNvbHV0aW9uIC1cblx0XHRcdFx0aWYgdElEIG1pc21hdGNoIGlzIGZvdW5kLFxuXHRcdFx0XHRcdGEgc2VhcmNoIG9mIG90aGVyIHRyYW5zcG9ydHMgd2l0aCB0aGUgc2FtZSB0TmFtZSBpcyBkb25lLFxuXHRcdFx0XHRcdCBcdGlmIGZvdW5kLCBzZW5kIGFzIHVzdWFsIGFuZCByZXNvbHZlXG5cdFx0XHRcdFx0XHRpZiBub3QgZm91bmQsXG5cdFx0XHRcdFx0XHRcdGNhbGwgaXMgaG9va2VkIGFuZCB3YWl0cyB0aWxsIGFub3RoZXIgdHJhbnNwb3J0IHdpdGggdGhlIHNhbWUgbmFtZSBjb25uZWN0cyBiZWZvcmUgdGltZW91dFxuXHRcdFx0XHRcdFx0XHRpZiBjb25uZWN0cyxcblx0XHRcdFx0XHRcdFx0XHRzZW5kIGFzIHVzdWFsICYgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRpZiBub3QsXG5cdFx0XHRcdFx0XHRcdFx0ZmFpbCB3aXRoIGEgdGltZW91dFxuXHRcdCovXG5cblx0XHRpZiAoIV9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbdGlkXSkge1xuXHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdcXG5cXG5bc2VuZFRvSURdIHRyYW5zcG9ydCB0byB0aWRbJXNdIGRvZXMgbm90IGV4aXN0LiBUYWtpbmcgY29ycmVjdGl2ZSBhY3Rpb24uLi4gXFxuJywgdGlkKTtcblxuXG5cdFx0XHR2YXIgdHJhbnMgPSBfc2VsZi5lbmRwb2ludC5maW5kVHJhbnNwb3J0QnlOYW1lKHBUcmFuc05hbWUpO1xuXG5cdFx0XHQvLyBJZiBmb3VuZCwgY29udGludWUgd2l0aCBkaXNjb3ZlcmVkIHRyYW5zcG9ydFxuXHRcdFx0aWYgKHRyYW5zKSB7XG5cdFx0XHRcdHRpZCA9IHRyYW5zLmlkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbHNlIHdhaXQgZm9yIGEgbmV3IHRyYW5zcG9ydCB0byBjb25uZWN0LCBvciByZWplY3Qgb24gdGltZW91dFxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG5cdFx0XHRcdFx0Ly8gV2FpdCBmb3IgbmV3IHRyYW5zcG9ydCB3aXRoIGdpdmVuIG5hbWUgdG8gc2V0dXBcblx0XHRcdFx0XHQudGhlbigoKSA9PiBfc2VsZi5lbmRwb2ludC5hZGRUcmFuc3BvcnROYW1lQ2hhbmdlSG9vayhwVHJhbnNOYW1lKSlcblxuXHRcdFx0XHRcdC8vIENhbGwgdGhpcyByZWN1cnNpdmVseSBhbmQgdHJ5IHRvIHJlc2VuZFxuXHRcdFx0XHRcdC50aGVuKCh0KSA9PiB0aGlzLnNlbmRUb0lEKHQuaWQsIG1zZywgbW9kZSwgcFRyYW5zTmFtZSkpXG5cblx0XHRcdFx0XHQvLyBSZWplY3QgaWYgaXQgZmFpbHMgKHdvcnN0IGNhc2Ugc2l0dWF0aW9uKVxuXHRcdFx0XHRcdC5jYXRjaCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci53YXJuKCdbRVJST1JdIHRyYW5zcG9ydCB0TmFtZVslc10gd2FzIG5vdCBmb3VuZCBhcyB0aWRbJXNdLiBNaWdodCBsZWFkIHRvIGR1cGxpY2F0ZWQgcHJvdmlkZXIgZXhlY3V0aW9ucywgaWYgcmUtY29ubmVjdGlvbnMgY2F1c2VkIGl0LicsIHROYW1lLCB0aWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIW1vZGUgfHwgbW9kZSAhPSAncmVzcG9uZCcpIHtcblx0XHRcdFx0XHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIud2FybignQ2Fubm90IGNhbGwgLSBtaXNzaW5nIHRyYW5zcG9ydCcpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcblx0XHRcdFx0XHRcdFx0XHRzZW50OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXM6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zcG9ydDogcFRyYW5zTmFtZSxcblx0XHRcdFx0XHRcdFx0XHRjb21tYW5kOiBfc2VsZi5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlOiAndHJhbnNwb3J0IHJlbW92ZWQgb3IgY2hhbmdlZCdcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci53YXJuKCdDYW5ub3QgcmVzcG9uZCAtIG1pc3NpbmcgdHJhbnNwb3J0Jyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdCgndHJhbnNwb3J0IG1pc3NpbmcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBOT1RFIC0gSW4gY2FzZSB0aGUgdE5hbWUgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGNhbGxcblx0XHR2YXIgdE5hbWUgPSBfc2VsZi5lbmRwb2ludC50cmFuc3BvcnRzW3RpZF0udE5hbWU7XG5cblx0XHRtc2cuc291cmNlID0gX3NlbGYuZW5kcG9pbnQubGFiZWw7XG5cdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdTZW5kaW5nIG9uIHRyYW5zcG9ydCBbJXNdWyVzXSwgbW9kZSA9ICVzLCAgbXNnID0nLCB0aWQsIHROYW1lLCBtb2RlLCBtc2cpO1xuXG5cblx0XHRpZiAoIW1vZGUgfHwgbW9kZSAhPSAncmVzcG9uZCcpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXG5cdFx0XHRcdHZhciBzZW50ID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gaGFuZGxlciBmdW5jdGlvblxuXHRcdFx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChyZXNwRGF0YSwgbXNnVHlwZSkge1xuXHRcdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnXFxuXFxuUmVzcG9uc2UgaGFuZGxlciBjYWxsZWQgd2l0aCByZXNwRGF0YSAmIG1zZ1R5cGVzIGFzIFxcbicsIHJlc3BEYXRhLCBtc2dUeXBlKTtcblxuXHRcdFx0XHRcdGRlbGV0ZSBfc2VsZi5yZXNwb25zZUhhbmRsZXJzW3ROYW1lXVttc2cubXNnSURdO1xuXG5cblx0XHRcdFx0XHRzd2l0Y2ggKG1zZ1R5cGUpIHtcblxuXHRcdFx0XHRcdGNhc2UgTUVTU0FHRVRZUEVTLnJlc3BvbnNlQWNjZXB0OlxuXHRcdFx0XHRcdFx0cmVzKHtcblx0XHRcdFx0XHRcdFx0c2VudDogc2VudCxcblx0XHRcdFx0XHRcdFx0c3RhdHVzOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHR0cmFuc3BvcnQ6IHROYW1lLFxuXHRcdFx0XHRcdFx0XHRjb21tYW5kOiBfc2VsZi5uYW1lLFxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZTogcmVzcERhdGFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIE1FU1NBR0VUWVBFUy5yZXNwb25zZUZhaWw6XG5cdFx0XHRcdFx0XHRyZXMoe1xuXHRcdFx0XHRcdFx0XHRzZW50OiBzZW50LFxuXHRcdFx0XHRcdFx0XHRzdGF0dXM6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHR0cmFuc3BvcnQ6IHROYW1lLFxuXHRcdFx0XHRcdFx0XHRjb21tYW5kOiBfc2VsZi5uYW1lLFxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZTogcmVzcERhdGFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH07XG5cblxuXHRcdFx0XHRpZiAoIV9zZWxmLnJlc3BvbnNlSGFuZGxlcnNbdE5hbWVdKVxuXHRcdFx0XHRcdF9zZWxmLnJlc3BvbnNlSGFuZGxlcnNbdE5hbWVdID0ge307XG5cblx0XHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdcXG5cXG5BZGRpbmcgcmVzcG9uc2UgaGFuZGxlciBhdCBbJXNdWyVzXSBcXG4nLCB0TmFtZSwgbXNnLm1zZ0lEKTtcblx0XHRcdFx0X3NlbGYucmVzcG9uc2VIYW5kbGVyc1t0TmFtZV1bbXNnLm1zZ0lEXSA9IGhhbmRsZXI7XG5cblxuXHRcdFx0XHR2YXIgY29udGFpbmVyID0ge1xuXHRcdFx0XHRcdHJwY19tc2c6IHt9LFxuXHRcdFx0XHRcdHJwY19kaXI6IF9zZWxmLmVuZHBvaW50LmRpclxuXHRcdFx0XHR9O1xuXHRcdFx0XHRjb250YWluZXIucnBjX21zZ1tfc2VsZi5uYW1lXSA9IG1zZztcblxuXHRcdFx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci5sb2coJ1xcblxcblxcblNlbmRpbmcgJXMgdG8gWyVzXSBhcyBcXG4nLCBtb2RlID09ICdyZXNwb25kJyA/ICdyZXNwb25zZScgOiAncmVxdWVzdCcsIHROYW1lLCBjb250YWluZXIpO1xuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUoX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1t0aWRdLnNlbmQoY29udGFpbmVyKSlcblx0XHRcdFx0XHQudGhlbigocykgPT4gc2VudCA9IHRydWUpXG5cdFx0XHRcdFx0LmNhdGNoKChlKSA9PiB7XG5cdFx0XHRcdFx0XHRzZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRoYW5kbGVyKGUsIE1FU1NBR0VUWVBFUy5yZXNwb25zZUZhaWwpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgY29udGFpbmVyID0ge1xuXHRcdFx0XHRycGNfbXNnOiB7fSxcblx0XHRcdFx0cnBjX2RpcjogX3NlbGYuZW5kcG9pbnQuZGlyXG5cdFx0XHR9O1xuXHRcdFx0Y29udGFpbmVyLnJwY19tc2dbX3NlbGYubmFtZV0gPSBtc2c7XG5cblx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnXFxuXFxuXFxuU2VuZGluZyAlcyB0byBbJXNdIGFzIFxcbicsIG1vZGUgPT0gJ3Jlc3BvbmQnID8gJ3Jlc3BvbnNlJyA6ICdyZXF1ZXN0JywgdE5hbWUsIGNvbnRhaW5lcik7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbdGlkXS5zZW5kKGNvbnRhaW5lcikpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHRcdERhdGEgY2FuIGJlIGEgdmFsdWUgb3IgYSBmdW5jdGlvbi5cblx0XHRJZiBpdHMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBldmFsdWF0ZWQgZm9yIGV2ZXJ5IG5ldyB0cmFuc3BvcnQgYW5kIHBhc3NlZCB0aGUgdHJhbnNwb3J0IG5hbWUgJiBpbmRleCBhcyBwYXJhbWV0ZXJzLlxuXHQqL1xuXHRycGNDb21tYW5kLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgZGF0YSwgbW9kZSkge1xuXHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHROYW1lO1xuXHRcdG5hbWVzcGFjZSA9IG5ldyBOYW1lc3BhY2UobmFtZXNwYWNlKTtcblx0XHR2YXIgdGFza3MgPSBbXTtcblx0XHR2YXIgZXZhbHVhdGUgPSBmYWxzZTtcblxuXHRcdHZhciBtc2cgPSB7XG5cdFx0XHRtc2dJRDogX3NlbGYuYXV0b0lEKCksXG5cdFx0XHRtc2dUeXBlOiBNRVNTQUdFVFlQRVMucmVxdWVzdCxcblx0XHRcdHJlcURhdGE6IGRhdGEsXG5cdFx0fTtcblxuXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZXZhbHVhdGUgPSB0cnVlO1xuXHRcdH1cblxuXG5cdFx0T2JqZWN0LmtleXMoX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0cylcblx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uICh0aWQsIGluZGV4KSB7XG5cdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnU2Nhbm5pbmcgZm9yIG5hbWVzcGFjZSBvbiB0cmFuc3BvcnQgWyVzXSBhcyBcXG4nLCB0aWQpO1xuXG5cdFx0XHRcdHROYW1lID0gX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1t0aWRdLnROYW1lO1xuXG5cdFx0XHRcdGlmIChfc2VsZi5lbmRwb2ludC50cmFuc3BvcnRzW3RpZF0uaW5pdGlhbGlzZWQgPT09IHRydWUgJiYgbmFtZXNwYWNlLnRlc3QodE5hbWUpKSB7XG5cdFx0XHRcdFx0aWYgKGV2YWx1YXRlID09PSB0cnVlKVxuXHRcdFx0XHRcdFx0bXNnLnJlcURhdGEgPSBkYXRhKF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbdGlkXS50TmFtZSwgaW5kZXgpO1xuXHRcdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnVHJhbnNwb3J0IFslc10gaXMgdmFsaWQuIEF0dGVtcHRpbmcgdG8gc2VuZCcsIHRpZCk7XG5cblx0XHRcdFx0XHQvLyBOT1RFIC0gYWRkaW5nIHROYW1lIGF0IHRoZSBlbmQgYXMgaWRlbnRpZmljYXRpb24gaW4gY2FzZSBvZiB0TmFtZSBlcnJvcnMuIFNlZSAuc2VuZFRvSUQoKSBjb21tZW50cy5cblx0XHRcdFx0XHR0YXNrcy5wdXNoKF9zZWxmLnNlbmRUb0lEKHRpZCwgbXNnLCBtb2RlLCB0TmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdGlmICh0YXNrcy5sZW5ndGggPiAwKVxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHRhc2tzKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFt7XG5cdFx0XHRcdHNlbnQ6IGZhbHNlLFxuXHRcdFx0XHRzdGF0dXM6IGZhbHNlLFxuXHRcdFx0XHR0cmFuc3BvcnQ6ICcnLFxuXHRcdFx0XHRjb21tYW5kOiBfc2VsZi5uYW1lLFxuXHRcdFx0XHRyZXNwb25zZTogJ25vIHRyYW5zcG9ydHMgYWRkZWQnXG5cdFx0XHR9XSk7XG5cdH07XG5cblx0Ly8gcnBjQ29tbWFuZC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChuYW1lc3BhY2VTdHJpbmcsIGRhdGEpIHtcblx0Ly8gXHR2YXIgX3NlbGYgPSB0aGlzO1xuXHQvL1xuXHQvLyBcdHZhciBtc2cgPSB7XG5cdC8vIFx0XHRtc2dJRDogX3NlbGYuYXV0b0lEKCksXG5cdC8vIFx0XHRtc2dUeXBlOiBNRVNTQUdFVFlQRVMucmVxdWVzdCxcblx0Ly8gXHRcdHJlcURhdGE6IGRhdGEsXG5cdC8vIFx0fTtcblx0Ly9cblx0Ly9cblx0Ly8gXHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci5sb2coJ1JlcXVlc3RpbmcgUlBDIHdpdGggbXNnID0gJywgbXNnKTtcblx0Ly8gXHRyZXR1cm4gX3NlbGYuc2VuZChuYW1lc3BhY2VTdHJpbmcsIG1zZyk7XG5cdC8vXG5cdC8vIH07XG5cblxuXHRycGNDb21tYW5kLnByb3RvdHlwZS5yZWNpZXZlID0gZnVuY3Rpb24gKG1zZywgdHJhbnNwb3J0KSB7XG5cdFx0dmFyIF9zZWxmID0gdGhpcztcblx0XHR2YXIgdE5hbWUgPSB0cmFuc3BvcnQudE5hbWUsXG5cdFx0XHR0aWQgPSB0cmFuc3BvcnQuaWQ7XG5cblx0XHRfc2VsZi5yZWN2TG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYucmVjdkxvZ2dlci5sb2coJ1xcblxcblxcbkNvbW1hbmQgWyVzXSBEYXRhIHJlY3ZkIG9uIFslc11bJXNdIGFzIFxcbicsIF9zZWxmLm5hbWUsIF9zZWxmLmVuZHBvaW50LmxhYmVsLCBfc2VsZi5lbmRwb2ludC5kaXIsIHROYW1lLCBtc2cpO1xuXG5cdFx0c3dpdGNoIChtc2cubXNnVHlwZSkge1xuXHRcdGNhc2UgTUVTU0FHRVRZUEVTLnJlc3BvbnNlQWNjZXB0OlxuXHRcdGNhc2UgTUVTU0FHRVRZUEVTLnJlc3BvbnNlRmFpbDpcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG5SZXNwb25zZSByZWN2ZCBvbiBbJXNdIGZyb20gWyVzXSBhc1xcbiAnLHROYW1lLCBtc2cucnROYW1lLCBtc2cpO1xuXHRcdFx0aWYgKF9zZWxmLnJlc3BvbnNlSGFuZGxlcnNbdE5hbWVdICYmIF9zZWxmLnJlc3BvbnNlSGFuZGxlcnNbdE5hbWVdW21zZy5yZXNwSURdKSB7XG5cdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnaGFuZGxlciBmb3VuZC4gUmVzcG9uZGluZyAhJyk7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoX3NlbGYucmVzcG9uc2VIYW5kbGVyc1t0TmFtZV1bbXNnLnJlc3BJRF0obXNnLnJlc3BEYXRhLCBtc2cubXNnVHlwZSkpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci5sb2coJ2hhbmRsZXIgbm90IGZvdW5kJyk7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2hhbmRsZXIgbm90IGZvdW5kJykpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIE1FU1NBR0VUWVBFUy5yZXF1ZXN0OlxuXHRcdFx0Ly8gY29uc29sZSAubG9nKCdcXG5cXG5Db21tYW5kWyVzXSBSZXF1ZXN0IHJlY3ZkIG9uIFslc10gYXNcXG4gJyxfc2VsZi5uYW1lLCB0TmFtZSxtc2cpO1xuXG5cdFx0XHRpZiAoX3NlbGYucmVxdWVzdEhhbmRsZXJzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1xcblslc11SZXF1ZXN0IGhhbmRsZXJzIGZvdW5kXFxuICcsX3NlbGYucmVxdWVzdEhhbmRsZXJzLmxlbmd0aCk7XG5cblx0XHRcdFx0dmFyIGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdHZhciByZXFEYXRhID0gbXNnLnJlcURhdGE7XG5cblx0XHRcdFx0X3NlbGYucmVxdWVzdEhhbmRsZXJzLmZvckVhY2goKGgpID0+IHtcblx0XHRcdFx0XHQvKiBFYWNoIGhhbmRsZXIgaXMgY2FsbGVkIHdpdGggKHYscCxzLHQsbXNnKSBhcyBmb2xsb3dzXG5cdFx0XHRcdFx0XHR2XHQ9IHJlcURhdGEgXHQtIGRhdGEgc2VudCBieSBjYWxsZXIsXG5cdFx0XHRcdFx0XHRwXHQ9IHByZXZcdFx0LSByZXNwb25zZSBnb3QgZnJvbSB0aGUgcHJldmhhbmRsZXIncyBleGVjdXRpb24gZm9yIHRoaXMgY2FsbCxcblx0XHRcdFx0XHRcdHMgXHQ9IG1zZy5zb3VyY2UgXHQtIG5hbWUgb2YgdGhlIGNhbGxpbmcgdHJhbnNwb3J0ICh0aGlzIHdhcyB0aGUgYWN0dWFsIHVzZWNhc2UgZm9yIHROYW1lID8pXG5cdFx0XHRcdFx0XHR0XHQ9IHROYW1lIFx0XHQtIG5hbWUgb2YgY3VycmVudCB0cmFuc3BvcnQgKFRPRE8gLSBidWdneSwgcG9pbnRzIHRvIGxvY2FsIHRyYW5zcG9ydCBuYW1lKVxuXHRcdFx0XHRcdFx0bXNnIFx0PSBtc2cgXHRcdC0gZnVsbCByYXcgbXNnIG9ialxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0Y2hhaW4gPSBjaGFpbi50aGVuKChwcmV2KSA9PiBoKG1zZy5yZXFEYXRhLCBwcmV2LCBtc2cuc291cmNlLCB0TmFtZSwgbXNnKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gY2hhaW5cblx0XHRcdFx0XHQudGhlbigocmVzcERhdGEpID0+IHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdcXG5SZXF1ZXN0IGhhbmRsZXJzIFNVQ0NFU1NcXG4gUmVzdWx0cyBhcmUnLHJlc3BEYXRhKTtcblxuXHRcdFx0XHRcdFx0bXNnLnJlc3BJRCA9IG1zZy5tc2dJRDtcblx0XHRcdFx0XHRcdG1zZy5ydE5hbWUgPSB0TmFtZTtcblx0XHRcdFx0XHRcdG1zZy5tc2dJRCA9IF9zZWxmLmF1dG9JRCgpO1xuXHRcdFx0XHRcdFx0bXNnLm1zZ1R5cGUgPSBNRVNTQUdFVFlQRVMucmVzcG9uc2VBY2NlcHQ7XG5cdFx0XHRcdFx0XHRtc2cucmVzcERhdGEgPSByZXNwRGF0YTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBtc2cucmVxRGF0YTtcblx0XHRcdFx0XHRcdHJldHVybiBfc2VsZi5zZW5kVG9JRCh0aWQsIG1zZywgJ3Jlc3BvbmQnLCB0TmFtZSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY2F0Y2goKGUpID0+IHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdcXG5SZXF1ZXN0IGhhbmRsZXJzIEZBSUxFRFxcbiBSZXN1bHRzIGFyZScsZSk7XG5cblx0XHRcdFx0XHRcdG1zZy5yZXNwSUQgPSBtc2cubXNnSUQ7XG5cdFx0XHRcdFx0XHRtc2cucnROYW1lID0gdE5hbWU7XG5cdFx0XHRcdFx0XHRtc2cubXNnSUQgPSBfc2VsZi5hdXRvSUQoKTtcblx0XHRcdFx0XHRcdG1zZy5tc2dUeXBlID0gTUVTU0FHRVRZUEVTLnJlc3BvbnNlRmFpbDtcblx0XHRcdFx0XHRcdG1zZy5yZXNwRGF0YSA9IGU7XG5cdFx0XHRcdFx0XHRkZWxldGUgbXNnLnJlcURhdGE7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX3NlbGYuc2VuZFRvSUQodGlkLCBtc2csICdyZXNwb25kJywgdE5hbWUpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnRoZW4oKCkgPT4gX3NlbGYub25Qcm92aWRlRm4gPyBfc2VsZi5vblByb3ZpZGVGbihyZXFEYXRhLCBtc2cucmVzcERhdGEsIHROYW1lLCBtc2cpIDogbnVsbClcblx0XHRcdFx0XHQuY2F0Y2goKGUpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1tPY3RvcHVzXSBFcnJvciB3aGlsZSBleGVjdXRpbmcgWyVzXSBwcm92aWRlciBjaGFpbiBvbiBbJXNdIC0gJywgX3NlbGYubmFtZSwgdE5hbWUsIGUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfc2VsZi5yZWN2TG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYucmVjdkxvZ2dlci5lcnJvcignRVJST1IgLSBObyByZXF1ZXN0SGFuZGxlcnMgZm9yIGNvbW1hbmRbJXNdIG9uIFslc11bJXNdIC0gIHROYW1lLCBtc2cgLSAnLCBfc2VsZi5uYW1lLCBfc2VsZi5lbmRwb2ludC5sYWJlbCwgX3NlbGYuZW5kcG9pbnQuZGlyLCB0TmFtZSwgbXNnKTtcblx0XHRcdFx0bXNnLnJlc3BJRCA9IG1zZy5tc2dJRDtcblx0XHRcdFx0bXNnLnJ0TmFtZSA9IHROYW1lO1xuXHRcdFx0XHRtc2cubXNnSUQgPSBfc2VsZi5hdXRvSUQoKTtcblx0XHRcdFx0bXNnLm1zZ1R5cGUgPSBNRVNTQUdFVFlQRVMucmVzcG9uc2VGYWlsO1xuXHRcdFx0XHRtc2cucmVzcERhdGEgPSAnbm8gcHJvdmlkZXJzJztcblx0XHRcdFx0ZGVsZXRlIG1zZy5yZXFEYXRhO1xuXHRcdFx0XHRyZXR1cm4gX3NlbGYuc2VuZFRvSUQodGlkLCBtc2csICdyZXNwb25kJywgdE5hbWUpO1xuXG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0cnBjQ29tbWFuZC5wcm90b3R5cGUucHJvdmlkZSA9IGZ1bmN0aW9uIChmbikge1xuXHRcdGlmICh0eXBlb2YgZm4gPT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0dGhpcy5yZXF1ZXN0SGFuZGxlcnMucHVzaChmbik7XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtIHBhc3NlZCB0byBcInByb3ZpZGVcIiBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0fTtcblxuXHRycGNDb21tYW5kLnByb3RvdHlwZS51blByb3ZpZGUgPSBmdW5jdGlvbiAoZm4pIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLnJlcXVlc3RIYW5kbGVycy5maW5kSW5kZXgoKHgpID0+IHggPT09IGZuKTtcblx0XHRpZiAoaW5kZXggPiAtMSlcblx0XHRcdHRoaXMucmVxdWVzdEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Lypcblx0XHRFeGVjdXRlcyBwYXNzZWQgZm4gd2hlbiBwcm92aWRlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWxseSByZWNpZXZlZCBieSByZW1vdGUuXG5cdFx0XHRBc3N1bWluZyB0cmFuc3BvcnQgc2VuZCgpIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIG9uIHN1Y2Nlc3NmdWxsXG5cdFx0XHR0cmFuc2ZlciBvZiByZXNwb25zZSBtZXNzYWdlXG5cdCovXG5cdHJwY0NvbW1hbmQucHJvdG90eXBlLm9uUHJvdmlkZSA9IGZ1bmN0aW9uIChmbikge1xuXHRcdGlmICh0eXBlb2YgZm4gPT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0dGhpcy5vblByb3ZpZGVGbiA9IGZuO1xuXHRcdGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYXJhbSBwYXNzZWQgdG8gXCJvblByb3ZpZGVGblwiIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHR9O1xuXG5cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBycGNDb21tYW5kO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL25hbWVzcGFjZS5qcycpO1xuXHRjb25zdCBycGNTdG9ja1RyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3N0b2NrVHJhbnNwb3J0cy5qcycpO1xuXHRjb25zdCBycGNUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3JwY1RyYW5zcG9ydC5qcycpO1xuXHRjb25zdCBycGNDb21tYW5kID0gcmVxdWlyZSgnLi9ycGNDb21tYW5kLmpzJyk7XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXHR2YXIgcnBjRW5kcG9pbnQgPSBmdW5jdGlvbiAobCwgZGlyLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlci5jaGlsZChkaXIgPT0gJ2knID8gJ0VQOmluJyA6ICdFUDpvdXQnKTtcblxuXG5cdFx0dGhpcy50cmFuc3BvcnRzID0ge307XG5cdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3MgPSB7fTtcblx0XHR0aGlzLmxhYmVsID0gbDtcblx0XHR0aGlzLmRpciA9IGRpcjtcblx0XHR0aGlzLmNvbW1hbmRzID0ge307XG5cdFx0dGhpcy50cmFuc3BvcnRUeXBlcyA9IHJwY1N0b2NrVHJhbnNwb3J0cztcblxuXHRcdHRoaXMubG9nZ2VyLmVuYWJsZWQgJiYgdGhpcy5sb2dnZXIubG9nKCdDcmVhdGVkIG5ldyBlbmRwb2ludCBhcyBbJXNdWyVzXScsIGwsIGRpcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRycGNFbmRwb2ludC5wcm90b3R5cGUucGx1Z2luVHJhbnNwb3J0cyA9IGZ1bmN0aW9uICh0Q29sbCkge1xuXHRcdHRoaXMudHJhbnNwb3J0VHlwZXMgPSBPYmplY3QuYXNzaWduKHRoaXMudHJhbnNwb3J0VHlwZXMsIHRDb2xsKTtcblx0fTtcblxuXHRycGNFbmRwb2ludC5wcm90b3R5cGUub3ZlciA9IGZ1bmN0aW9uIChzb2NrZXQsIHR5cGUpIHtcblx0XHRyZXR1cm4gbmV3IHJwY1RyYW5zcG9ydCh0eXBlLCBzb2NrZXQsIHRoaXMsIHsgbG9nZ2VyOiB0aGlzLmxvZ2dlciB9KTtcblx0fTtcblx0cnBjRW5kcG9pbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcblx0XHR2YXIgX3NlbGYgPSB0aGlzO1xuXHRcdC8vIE9iamVjdC5rZXlzKF9zZWxmLnRyYW5zcG9ydHMpLmZvckVhY2goKHRpZCkgPT4ge1xuXHRcdC8vIFx0aWYgKF9zZWxmLnRyYW5zcG9ydHNbdGlkXS5zb2NrZXQgPT0gc29ja2V0KXtcblx0XHQvLyBcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnRGVzdHJveWluZyAmIHJlbW92aW5nIHRyYW5zcG9ydCBbJXNdIHROYW1lIFslc10uICcsdGlkLF9zZWxmLnRyYW5zcG9ydHNbdGlkXS50TmFtZSk7XG5cdFx0Ly8gXHRcdF9zZWxmLnRyYW5zcG9ydHNbdGlkXS5kZXN0cm95KCk7XG5cdFx0Ly8gXHRcdGRlbGV0ZSBfc2VsZi50cmFuc3BvcnRzW3RpZF07XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdBdHRlbXB0aW5nIHRvIHJlbW92ZSBzb2NrZXQuICcsc29ja2V0Ll9vY3RvcHVzKTtcblx0XHQvLyBfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdDdXJyZW50IGVuZHBvaW50WyVzXVslc10gdHJhbnNwb3J0cyBhcmUgLiAnLF9zZWxmLmxhYmVsLCBfc2VsZi5kaXIsIF9zZWxmLnRyYW5zcG9ydHMpO1xuXG5cdFx0aWYgKHNvY2tldCAmJiBzb2NrZXQuX29jdG9wdXMgJiYgc29ja2V0Ll9vY3RvcHVzLnRyYW5zcG9ydHMpIHtcblxuXHRcdFx0Ly8gR28gdGhyb3VnaCB0cmFuc3BvcnRzIGFkZGVkIHRvIHNvY2tldFxuXHRcdFx0c29ja2V0Ll9vY3RvcHVzLnRyYW5zcG9ydHMuZm9yRWFjaCgodCkgPT4ge1xuXG5cdFx0XHRcdC8vIFNlZSBpZiBpdHMgYSB0cmFuc3BvcnQgb2YgdGhpcyBlbmRwb2ludFxuXHRcdFx0XHR2YXIgZm91bmRUID0gT2JqZWN0LmtleXMoX3NlbGYudHJhbnNwb3J0cykuZmluZCh4ID0+IF9zZWxmLnRyYW5zcG9ydHNbeF0gPT09IHQpO1xuXG5cdFx0XHRcdC8vIGlmIGZvdW5kLCBkaXNhc3NvY2lhdGUgZnJvbSBzb2NrZXQsIGRlc3Ryb3kgYW5kIGRlbGV0ZSBmcm9tIGVuZHBvaW50XG5cdFx0XHRcdGlmIChmb3VuZFQpIHtcblx0XHRcdFx0XHRmb3VuZFQgPSBfc2VsZi50cmFuc3BvcnRzW2ZvdW5kVF07XG5cdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLndhcm4oJ0Rlc3Ryb3lpbmcgJiByZW1vdmluZyB0cmFuc3BvcnQgWyVzXSB0TmFtZSBbJXNdIGZyb20gZW5kcG9pbnRbJXNdWyVzXS4gJywgZm91bmRULmlkLCBmb3VuZFQudE5hbWUsIF9zZWxmLmxhYmVsLCBfc2VsZi5kaXIpO1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gc29ja2V0Ll9vY3RvcHVzLnRyYW5zcG9ydHMuZmluZEluZGV4KHggPT4geCA9PSB0KTtcblx0XHRcdFx0XHRzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG5cblx0XHRcdFx0XHRmb3VuZFQuZGVzdHJveSgpO1xuXHRcdFx0XHRcdGRlbGV0ZSBfc2VsZi50cmFuc3BvcnRzW2ZvdW5kVC5pZF07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRycGNFbmRwb2ludC5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkge1xuXG5cdFx0Lypcblx0XHRcdE5PVEUgLSBNdXN0IGludmVzdGlnYXRlIGlmIHRoZXJlIGFyZSBzaWRlIGVmZmVjdHMgP1xuXG5cdFx0XHRTaG91bGQgd2UgYmUgYWxsb3dlZCB0byBjaGFuZ2UgcmVtb3RlIHNpZGUgbmFtZSA/XG5cdFx0XHRcdEFueSB1c2VjYXNlIHdoZXJlIHdlIG5lZWQgaXQgP1xuXG5cdFx0XHRJZiBvdXIgbmFtZSBjaGFuZ2UgaXMgYWNjZXB0ZWQgYnkgcmVtb3RlIHNpZGUsXG5cdFx0XHQgXHRzaG91bGQgaXQgdHJpZ2dlciBuYW1lIGNoYW5nZXMgd2l0aCBvdGhlciBjb25uZWN0ZWQgdHJhbnNwb3J0cyB0b28gPyBzaW5jZSB0aGVyZSBjYW4gb25seSBiZSBvbmUgbmFtZSBmb3IgdGhlIHJlbW90ZS5cblxuXHRcdFx0SWYgd2UgY2hhbmdlIHRoZSByZW1vdGUncyBuYW1lLFxuXHRcdFx0XHRzaG91bGQgaXQgdHJpZ2dlciBuYW1lIGNoYW5nZXMgd2l0aCBvdGhlciBjb25uZWN0ZWQgdHJhbnNwb3J0cyB0b28gPyBzaW5jZSB0aGVyZSBjYW4gb25seSBiZSBvbmUgbmFtZSBmb3IgdGhlIHJlbW90ZS5cblxuXHRcdFx0SWYgc28sXG5cdFx0XHRcdENvdWxkIHRoaXMgY2F1c2UgaW5maW5pdGUgbG9vcHMgLyByaXBwbGVzID9cblxuXHRcdFx0Rm9yIGVnIC0gU2F5IGNvbm5lY3Rpb24gcGF0aCBpcyBzZXR1cCBhc1xuXHRcdFx0XHRBIC0gQiAtIEMgLSBEIC0gQVxuXHRcdFx0XHQgICAgfF9fX19fX198XG5cblx0XHQqL1xuXHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0bmFtZXNwYWNlID0gbmV3IE5hbWVzcGFjZShuYW1lc3BhY2UpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhczogKG5ld05hbWUpID0+IHtcblx0XHRcdFx0X3NlbGYubGFiZWwgPSBuZXdOYW1lO1xuXHRcdFx0XHRPYmplY3Qua2V5cyhfc2VsZi50cmFuc3BvcnRzKS5mb3JFYWNoKCh0aWQpID0+IHtcblx0XHRcdFx0XHRpZiAobmFtZXNwYWNlLnRlc3QoX3NlbGYudHJhbnNwb3J0c1t0aWRdLnROYW1lKSkge1xuXHRcdFx0XHRcdFx0X3NlbGYudHJhbnNwb3J0c1t0aWRdLmFzKG5ld05hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBJbnRlcm5hbCBob29rIGNhbGxlZCBieSB0cmFuc3BvcnQsIHRvIHNpZ25hbCBhIG5hbWUgY2hhbmdlXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS50cmFuc3BvcnROYW1lQ2hhbmdlZCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcblxuXHRcdC8vIFJ1biBwYXN0IGFsbCByZWdpc3RlcmVkIGhvb2tzICYgc2VlIGlmIGFueSBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyB0TmFtZVxuXHRcdGlmICh0aGlzLm5hbWVDaGFuZ2VIb29rc1t0cmFuc3BvcnQudE5hbWVdKSB7XG5cdFx0XHR0aGlzLm5hbWVDaGFuZ2VIb29rc1t0cmFuc3BvcnQudE5hbWVdLmZvckVhY2goeCA9PiB4KHRyYW5zcG9ydCkpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHRcdFJldHVybnMgYSBvbmUtdGltZSBob29rIHByb21pc2UgdGhhdFxuXHRcdFx0MT4gcmVzb2x2ZXMgd2hlbiBhcHByb3ByaWF0ZSBuYW1lIGNoYW5nZSBvY2N1cnNcblx0XHRcdDI+IHJlamVjdHMgaWYgdGltZW91dCBoYXBwZW5zXG5cblx0XHQmIEF1dG9tYXRpY2FsbHkgY2xlYW5zIHVwIGFmdGVyIGl0IGV4ZWN1dGVzIG9uY2UgKHJlc29sdmUgb3IgcmVqZWN0KS5cblx0Ki9cblx0cnBjRW5kcG9pbnQucHJvdG90eXBlLmFkZFRyYW5zcG9ydE5hbWVDaGFuZ2VIb29rID0gZnVuY3Rpb24gKHROYW1lLCB0aW1lb3V0KSB7XG5cdFx0aWYgKCF0aGlzLm5hbWVDaGFuZ2VIb29rc1t0TmFtZV0pXG5cdFx0XHR0aGlzLm5hbWVDaGFuZ2VIb29rc1t0TmFtZV0gPSBbXTtcblxuXHRcdHZhciBwID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHR2YXIgZm4gPSAodHJhbnNwb3J0KSA9PiB7XG5cdFx0XHRcdGlmIChyZXMgJiYgIXAuZG9uZSkge1xuXHRcdFx0XHRcdHAuZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0dmFyIGkgPSB0aGlzLm5hbWVDaGFuZ2VIb29rc1t0TmFtZV0uZmluZEluZGV4KHggPT4geCA9PSBmbik7XG5cdFx0XHRcdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRyZXModHJhbnNwb3J0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLnB1c2goZm4pO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0aWYgKHJlaiAmJiAhcC5kb25lKSB7XG5cdFx0XHRcdFx0cC5kb25lID09IHRydWU7XG5cdFx0XHRcdFx0dmFyIGkgPSB0aGlzLm5hbWVDaGFuZ2VIb29rc1t0TmFtZV0uZmluZEluZGV4KHggPT4geCA9PSBmbik7XG5cdFx0XHRcdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRyZWooKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGltZW91dCB8fCA1MDAwKTtcblxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHA7XG5cdH07XG5cblx0cnBjRW5kcG9pbnQucHJvdG90eXBlLmRpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIF9zZWxmID0gdGhpcztcblx0XHR2YXIgbG9nU3RyaW5nID0gJ2tleVxcdFxcdFxcdG5hbWVcXHRcXHRcXHR0eXBlOmlkXFx0XFx0XFx0aW5pdGFsaXNlZFxcbic7XG5cdFx0T2JqZWN0LmtleXMoX3NlbGYudHJhbnNwb3J0cykuZm9yRWFjaCgodEtleSkgPT4ge1xuXHRcdFx0bG9nU3RyaW5nICs9IGAke3RLZXl9XFx0XFx0JHtfc2VsZi50cmFuc3BvcnRzW3RLZXldLnROYW1lfVxcdFxcdCR7X3NlbGYudHJhbnNwb3J0c1t0S2V5XS50eXBlICsnOicrX3NlbGYudHJhbnNwb3J0c1t0S2V5XS5pZH1cXHRcXHQke19zZWxmLnRyYW5zcG9ydHNbdEtleV0uaW5pdGlhbGlzZWR9XFxuYDtcblx0XHR9KTtcblx0XHRyZXR1cm4gbG9nU3RyaW5nO1xuXHR9O1xuXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IHJwY0NvbW1hbmQobmFtZSwgdGhpcywgeyBsb2dnZXI6IHRoaXMubG9nZ2VyIH0pO1xuXHR9O1xuXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5maW5kVHJhbnNwb3J0QnlOYW1lID0gZnVuY3Rpb24gKHROYW1lKSB7XG5cdFx0dmFyIHRLZXkgPSBPYmplY3Qua2V5cyh0aGlzLnRyYW5zcG9ydHMpLmZpbmQoeCA9PiB0aGlzLnRyYW5zcG9ydHNbeF0udE5hbWUgPT0gdE5hbWUpO1xuXG5cdFx0aWYgKHRLZXkpXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc3BvcnRzW3RLZXldO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJwY0VuZHBvaW50O1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblx0dmFyIGlkQ291bnQgPSAwO1xuXHR2YXIgYXV0b0lEID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnVCcgKyAoKytpZENvdW50KTtcblx0fTtcblxuXHR2YXIgcnBjVHJhbnNwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIHNvY2tldCwgZW5kcG9pbnQsIG9wdGlvbnMpIHtcblx0XHQvLyBjb25zb2xlLmxvZygnQ3JlYXRpbmcgcnBjIHRyYW5zcG9ydCBbJXNdIGZvciBlbmRwb2ludCBbJXNdWyVzXScsdHlwZSwgZW5kcG9pbnQubGFiZWwsIGVuZHBvaW50LmRpcik7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dmFyIF9zZWxmID0gdGhpcztcblxuXHRcdF9zZWxmLmlkID0gYXV0b0lEKCk7XG5cdFx0X3NlbGYubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIuY2hpbGQoJ1Q6JyArIHR5cGUgKyAnOicgKyBfc2VsZi5pZCk7XG5cblx0XHRfc2VsZi5lbmRwb2ludCA9IGVuZHBvaW50O1xuXHRcdF9zZWxmLnR5cGUgPSB0eXBlO1xuXHRcdF9zZWxmLnNvY2tldCA9IHNvY2tldDsgLy8gQWxzbyB1c2VkIGZvciBtYXRjaGluZyAmIHJlbW92YWwsIGJlc2lkZXMgaW50ZXJuYWwgc29ja2V0IGFjY2Vzcy5cblx0XHRfc2VsZi50TmFtZSA9ICdub25uYW1lJztcblx0XHRfc2VsZi5pbml0aWFsaXNlZCA9IGZhbHNlO1xuXHRcdF9zZWxmLmRpc2FibGVkID0gZmFsc2U7XG5cdFx0X3NlbGYubmFtZUNsb2NrID0gMDtcblx0XHRfc2VsZi5kaXJGbGlwID0ge1xuXHRcdFx0aTogJ28nLFxuXHRcdFx0bzogJ2knXG5cdFx0fTtcblxuXHRcdC8vIEFkZCB0cmFzcG9ydCB0eXBlIHNwZWNpZmljIG1ldGhvZHMgdG8gc2VsZlxuXHRcdE9iamVjdC5hc3NpZ24oX3NlbGYsIF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydFR5cGVzW3R5cGVdKHR5cGUsIHNvY2tldCkpO1xuXHRcdGlmKCFzb2NrZXQuX29jdG9wdXMpXG5cdFx0XHRzb2NrZXQuX29jdG9wdXMgPSB7fTtcblxuXHRcdGlmKCFzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cylcblx0XHRcdHNvY2tldC5fb2N0b3B1cy50cmFuc3BvcnRzID0gW107XG5cblx0XHRpZighc29ja2V0Ll9vY3RvcHVzLnRyYW5zcG9ydHMuaW5jbHVkZXModGhpcykpXG5cdFx0XHRzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cy5wdXNoKHRoaXMpO1xuXG5cdFx0X3NlbGYuaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdF9zZWxmLnJlY3ZIYW5kbGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuXHRcdFx0XHQvLyBBYm9ydCBpZiB3ZSdyZSBkaXNhYmxlZFxuXHRcdFx0XHRpZihfc2VsZi5kaXNhYmxlZClcblx0XHRcdFx0XHRyZXR1cm47XG5cblxuXHRcdFx0XHQvLyBfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdbb25SZWN2XSBEYXRhIHJlY3ZkIG9uIFslc11bJXNdJyxfc2VsZi50TmFtZSxfc2VsZi5lbmRwb2ludC5kaXIsIGRhdGEpO1xuXHRcdFx0XHRpZiAoZGF0YS5ycGNfZGlyID09IF9zZWxmLmRpckZsaXBbX3NlbGYuZW5kcG9pbnQuZGlyXSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdbb25SZWN2XSBEYXRhIGFjY2VwdGVkIG9uIFslc11bJXNdJyxfc2VsZi50TmFtZSxfc2VsZi5lbmRwb2ludC5kaXIsIGRhdGEpO1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEucnBjX3ROYW1lX2NoYW5nZSkge1xuXHRcdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRcdFx0Tk9URSAtIEltcGxlbWVudGluZyBcIkxhdGVzdCAmIGxhc3Qgd3JpdGUgd2luc1wiIGNvbnNlbnN1cyBwb2xpY3kgOlxuXHRcdFx0XHRcdFx0XHRcdFdIWSA/IC0gUmVxdWlyZWQgdG8gc29sdmUgZGlzcHV0ZXMgd2hlbiBib3RoKG9yIG1vcmUpIGVuZHBvaW50cyByZXF1ZXN0IGEgbmFtZSBjaGFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cblx0XHRcdFx0XHRcdFx0XHRXaXRob3V0IHRoaXMsIGEgc2ltdWx0YW5lb3VzIHJlcXVlc3QgY2F1c2VzIGVhY2ggb25lIHRvIHNlbmRzIGhpcyBuYW1lIGNoYW5nZSBvdmVyIHdoaWxlIGltcGxlbWVudGluZyB0aGUgb3RoZXIncyBuYW1lIGNoYW5nZSByZXF1ZXN0LlxuXHRcdFx0XHRcdFx0XHRcdCBcdGNvbnNlcXVlbmNlIC0gYSBuYW1lIHN3YXAsIGluc3RlYWQgb2YgY29uc2Vuc3VzIG9uIGEgc2luZ2xlIG5hbWUgdmFsdWUuXG5cdFx0XHRcdFx0XHQqL1xuXG5cdFx0XHRcdFx0XHRpZihkYXRhLnJwY190TmFtZV9jaGFuZ2UucmVxdWVzdCA9PSB0cnVlKXtcblx0XHRcdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRcdFx0XHRPcHBvc2l0ZSBwYXJ0eSBoYXMgcmVxdWVzdGVkIGEgbmFtZSBjaGFuZ2UgdHJhbnNhY3Rpb24sIHRvIGJlIGluaXRpYXRlZCBmcm9tIGhlcmUuXG5cdFx0XHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0XHRcdF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ05hbWUgY2hhbmdlIHJlcXVlc3RlZCBieSByZW1vdGUuIEluaXRpYXRpbmcgdHJhbnNhY3Rpb24uLi4nLF9zZWxmLnROYW1lKTtcblxuXHRcdFx0XHRcdFx0XHRfc2VsZi5hcyhfc2VsZi50TmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChkYXRhLnJwY190TmFtZV9jaGFuZ2UuYWNrID09IHRydWUpIHtcblxuXHRcdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHRcdE9wcG9zaXRlIHBhcnR5IGhhcyBhY2NlcHRlZCB0aGUgbmFtZSBjaGFuZ2UgdGhhdCB3ZSBwcm9wb3NlZC5cblx0XHRcdFx0XHRcdFx0XHRIdXJyYXkuIFNpZ25hbCBuYW1lY2hhbmdlIHRvIGVuZHBvaW50ICYgcmVzb2x2ZS5cblx0XHRcdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnTmFtZSBjaGFuZ2UgdG8gWyVzXSBhY2tub3dsZWRnZWQuJyxfc2VsZi50TmFtZSk7XG5cblx0XHRcdFx0XHRcdFx0X3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0TmFtZUNoYW5nZWQoX3NlbGYpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3NlbGYuaW5pdGlhbGlzZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRfc2VsZi5pbml0aWFsaXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnY2hhbmdlZCBpbml0aWFsaXNlZCBzdGF0dXMgZnJvbSBmYWxzZSB0byB0cnVlJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmVzKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5ycGNfdE5hbWVfY2hhbmdlLmZvcmNlIHx8IGRhdGEucnBjX3ROYW1lX2NoYW5nZS5jbG9jayA+PSBfc2VsZi5uYW1lQ2xvY2spIHtcblxuXHRcdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHRcdE9wcG9zaXRlIHBhcnR5J3MgY2xvY2sgaXMgaGlnaGVyIG9yIGhhcyBhbHJlYWR5IHJlYWNoZWQgdGhlIHNhbWUgbGV2ZWwgKGllIGJlZm9yZSB1cykuXG5cdFx0XHRcdFx0XHRcdFx0QWNjZXB0IHRoZWlyIHByb3Bvc2FsLCBzZW5kIGFjaywgc2lnbmFsIG5hbWVjaGFuZ2UgdG8gZW5kcG9pbnRcblx0XHRcdFx0XHRcdFx0Ki9cblxuXHRcdFx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdbJXMsIGNsb2NrICVzXSBbJXNdIENoYW5naW5nIG5hbWUgb2YgdHJhbnNwb3J0IFslc11bJXNdIHRvIFslc10gYXQgY2xvY2sgPScsIF9zZWxmLmVuZHBvaW50LmxhYmVsLCBfc2VsZi5uYW1lQ2xvY2ssIGRhdGEucnBjX3ROYW1lX2NoYW5nZS5mb3JjZSA/ICdmb3JjZWQnIDogJycsIF9zZWxmLnROYW1lLCBfc2VsZi5pZCwgZGF0YS5ycGNfdE5hbWVfY2hhbmdlLnROYW1lLCBkYXRhLnJwY190TmFtZV9jaGFuZ2UuY2xvY2spO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWxldGUgX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1tfc2VsZi50TmFtZV07XG5cdFx0XHRcdFx0XHRcdF9zZWxmLnROYW1lID0gZGF0YS5ycGNfdE5hbWVfY2hhbmdlLnROYW1lO1xuXHRcdFx0XHRcdFx0XHRfc2VsZi5uYW1lQ2xvY2sgPSBkYXRhLnJwY190TmFtZV9jaGFuZ2UuY2xvY2s7XG5cdFx0XHRcdFx0XHRcdC8vIF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbX3NlbGYudE5hbWVdID0gX3NlbGY7XG5cblx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnTmFtZSBjaGFuZ2UgdG8gWyVzXSBhY2NlcHRlZC4nLF9zZWxmLnROYW1lKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZW5kIGFja1xuXHRcdFx0XHRcdFx0XHRfc2VsZi5zZW5kKHtcblx0XHRcdFx0XHRcdFx0XHRycGNfdE5hbWVfY2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0TmFtZTogX3NlbGYudE5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9jazogX3NlbGYubmFtZUNsb2NrLFxuXHRcdFx0XHRcdFx0XHRcdFx0YWNrOiB0cnVlXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRycGNfZGlyOiBfc2VsZi5lbmRwb2ludC5kaXJcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0X3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0TmFtZUNoYW5nZWQoX3NlbGYpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghX3NlbGYuaW5pdGlhbGlzZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRfc2VsZi5pbml0aWFsaXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0cmVzKCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHRcdE91ciBjbG9jayBpcyBoaWdoZXIsIHNvIGRvbid0IGFjY2VwdC5cblx0XHRcdFx0XHRcdFx0XHRQcm9wb3NlIG91ciBuYW1lIGluc3RlYWQuXG5cdFx0XHRcdFx0XHRcdCovXG5cblx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnWyVzLCBjbG9jayAlc10gWyVzXSBSZWplY3RpbmcgbmFtZSBjaGFuZ2Ugb2YgdHJhbnNwb3J0IFslc11bJXNdIGFzIFslc10gYXQgY2xvY2sgPScsIF9zZWxmLmVuZHBvaW50LmxhYmVsLCBfc2VsZi5uYW1lQ2xvY2ssIGRhdGEucnBjX3ROYW1lX2NoYW5nZS5mb3JjZSA/ICdmb3JjZWQnIDogJycsIF9zZWxmLnROYW1lLCBfc2VsZi5pZCwgZGF0YS5ycGNfdE5hbWVfY2hhbmdlLnROYW1lLCBkYXRhLnJwY190TmFtZV9jaGFuZ2UuY2xvY2spO1xuXHRcdFx0XHRcdFx0XHRfc2VsZi5zZW5kKHtcblx0XHRcdFx0XHRcdFx0XHRycGNfdE5hbWVfY2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0TmFtZTogX3NlbGYudE5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9jazogX3NlbGYubmFtZUNsb2NrLFxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yY2U6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdHJwY19kaXI6IF9zZWxmLmVuZHBvaW50LmRpclxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5ycGNfbXNnKSB7XG5cdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdE9iamVjdC5rZXlzKGRhdGEucnBjX21zZykuZm9yRWFjaCgoY0tleSkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdGlmIChfc2VsZi5lbmRwb2ludC5jb21tYW5kc1tjS2V5XSl7XG5cdFx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdC8vIF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ1tvblJlY3ZdIERhdGEgcmVjdmQgb24gWyVzXVslc10nLF9zZWxmLnROYW1lLF9zZWxmLmVuZHBvaW50LmRpciwgZGF0YSk7XG5cdFx0XHRcdFx0XHRcdFx0X3NlbGYuZW5kcG9pbnQuY29tbWFuZHNbY0tleV0ucmVjaWV2ZShkYXRhLnJwY19tc2dbY0tleV0sIF9zZWxmKVxuXHRcdFx0XHRcdFx0XHRcdC5jYXRjaCgoZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmVycm9yKCdbJXNdIEZhaWxlZCB0byByZXNwb25kIHRvIFslc10gcmVxdWVzdCAocmVnaXN0ZXJlZCkgZnJvbSBbJXNdIGJlY2F1c2UgLSAgJywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIGNLZXksIF9zZWxmLnROYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIHRlbXAgY29tbWFuZCBhbmQgcHJvY2Vzcy5cblx0XHRcdFx0XHRcdFx0XHRfc2VsZi5lbmRwb2ludC5jb21tYW5kKGNLZXkpLnJlY2lldmUoZGF0YS5ycGNfbXNnW2NLZXldLCBfc2VsZilcblx0XHRcdFx0XHRcdFx0XHQuY2F0Y2goKGUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5lcnJvcignWyVzXSBGYWlsZWQgdG8gcmVzcG9uZCB0byBbJXNdIHJlcXVlc3QgKHRlbXBvcmFyeSkgZnJvbSBbJXNdIGJlY2F1c2UgLSAgJywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIGNLZXksIF9zZWxmLnROYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0X3NlbGYub25SZWN2KF9zZWxmLnJlY3ZIYW5kbGVyKTtcblxuXHRcdFx0X3NlbGYuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ1slc10gRGVzdHJveWluZyB0cmFuc3BvcnQgWyVzXSA9JywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIF9zZWxmLnROYW1lKTtcblx0XHRcdFx0X3NlbGYuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRfc2VsZi5zb2NrZXQgPSBudWxsO1xuXG5cdFx0XHRcdGlmKF9zZWxmLnN0b3BSZWN2KXtcblx0XHRcdFx0XHQvLyBfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdbJXNdIERlc3Ryb3lpbmcgdHJhbnNwb3J0IFslc10gLSBzdG9wUmVjdiBmb3VuZCA9JywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIF9zZWxmLnROYW1lKTtcblx0XHRcdFx0XHRfc2VsZi5zdG9wUmVjdihfc2VsZi5yZWN2SGFuZGxlcik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmFzID0gZnVuY3Rpb24gKHROYW1lKSB7XG5cdFx0XHRcdC8vIGRlbGV0ZSBfc2VsZi5lbmRwb2ludC50cmFuc3BvcnRzW19zZWxmLnROYW1lXTtcblx0XHRcdFx0dmFyIHByZXZOYW1lID0gX3NlbGYudE5hbWU7XG5cdFx0XHRcdF9zZWxmLnROYW1lID0gdE5hbWU7XG5cdFx0XHRcdF9zZWxmLm5hbWVDbG9jaysrO1xuXHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdbJXNdIFNlbmRpbmcgbmFtZWNoYW5nZSBvZiB0cmFuc3BvcnQgWyVzXVslc10gdG8gWyVzXSBhdCBjbG9jayA9JywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIHByZXZOYW1lLCB0TmFtZSwgX3NlbGYuaWQsIF9zZWxmLm5hbWVDbG9jayk7XG5cdFx0XHRcdF9zZWxmLnNlbmQoe1xuXHRcdFx0XHRcdHJwY190TmFtZV9jaGFuZ2U6IHtcblx0XHRcdFx0XHRcdHROYW1lOiBfc2VsZi50TmFtZSxcblx0XHRcdFx0XHRcdGNsb2NrOiBfc2VsZi5uYW1lQ2xvY2tcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJwY19kaXI6IF9zZWxmLmVuZHBvaW50LmRpclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gLy8gX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1t0TmFtZV0gPSBfc2VsZjtcblx0XHRcdFx0Ly8gaWYoIV9zZWxmLmluaXRpYWxpc2VkKSB7XG5cdFx0XHRcdC8vIFx0X3NlbGYuaW5pdGlhbGlzZWQgPSB0cnVlO1xuXHRcdFx0XHQvLyBcdHJlcygpO1xuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdHJldHVybiBfc2VsZjtcblx0XHRcdH07XG5cblx0XHRcdC8vIFRyaWdnZXJzIGFuICcuYXMoKScgZnVuY3Rpb24gb24gdGhlIHJlbW90ZSBlbmQgb2YgdGhlIHNvY2tldC5cblx0XHRcdF9zZWxmLmFzUmVtb3RlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnUmVxdWVzdGluZyBuYW1lY2hhbmdlIGZyb20gcmVtb3RlLCBhdCBjbG9jayA9JywgX3NlbGYubmFtZUNsb2NrKTtcblx0XHRcdFx0X3NlbGYuc2VuZCh7XG5cdFx0XHRcdFx0cnBjX3ROYW1lX2NoYW5nZToge1xuXHRcdFx0XHRcdFx0cmVxdWVzdDp0cnVlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRycGNfZGlyOiBfc2VsZi5lbmRwb2ludC5kaXJcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIF9zZWxmO1xuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbX3NlbGYuaWRdID0gX3NlbGY7XG5cdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnQWRkZWQgdHJhbnNwb3J0IFslc11bJXNdIGZvciBlbmRwb2ludCBbJXNdWyVzXScsIHR5cGUsIF9zZWxmLmlkLCBlbmRwb2ludC5sYWJlbCwgZW5kcG9pbnQuZGlyKTtcblx0XHRyZXR1cm4gX3NlbGY7XG5cdH07XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5cdG1vZHVsZS5leHBvcnRzID0gcnBjVHJhbnNwb3J0O1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdHJhbnNwb3J0VHlwZXMgPSB7fTtcblxuXHR0cmFuc3BvcnRUeXBlc1snc29ja2V0aW8nXSA9IGZ1bmN0aW9uICh0eXBlLCBzb2NrZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogKGRhdGEpID0+IHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKSxcblx0XHRcdG9uUmVjdjogKGZuKSA9PiBzb2NrZXQub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4gZm4oSlNPTi5wYXJzZShkYXRhKSkpLFxuXHRcdFx0c3RvcFJlY3Y6IChmbikgPT4gc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG5cdFx0fVxuXHR9O1xuXHR0cmFuc3BvcnRUeXBlc1snd2Vic29ja2V0J10gPSBmdW5jdGlvbiAodHlwZSwgc29ja2V0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IChkYXRhKSA9PiB7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdFx0XHRzb2NrZXQuc2VuZChcblx0XHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuXHRcdFx0XHRcdFx0KGUpID0+IGUgPyByZWooZSkgOiByZXMoKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdG9uUmVjdjogKGZuKSA9PiBzb2NrZXQub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4gZm4oSlNPTi5wYXJzZShkYXRhKSkpLFxuXHRcdFx0c3RvcFJlY3Y6IChmbikgPT4gc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG5cdFx0fVxuXHR9O1xuXHR0cmFuc3BvcnRUeXBlc1sncHJvY2Vzc0xvY2FsJ10gPSBmdW5jdGlvbiAodHlwZSwgc29ja2V0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IChkYXRhKSA9PiBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIEpTT04uc3RyaW5naWZ5KGRhdGEpKSxcblx0XHRcdG9uUmVjdjogKGZuKSA9PiBzb2NrZXQub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4gZm4oSlNPTi5wYXJzZShkYXRhKSkpLFxuXHRcdFx0c3RvcFJlY3Y6IChmbikgPT4gc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG5cdFx0fVxuXHR9O1xuXHR0cmFuc3BvcnRUeXBlc1snbm9kZUVFTG9jYWwnXSA9IGZ1bmN0aW9uICh0eXBlLCBzb2NrZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogKGRhdGEpID0+IHNvY2tldC5lbWl0KCdtZXNzYWdlJywgSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxuXHRcdFx0b25SZWN2OiAoZm4pID0+IHNvY2tldC5vbignbWVzc2FnZScsIChkYXRhKSA9PiBmbihKU09OLnBhcnNlKGRhdGEpKSksXG5cdFx0XHRzdG9wUmVjdjogKGZuKSA9PiBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcblx0XHR9XG5cdH07XG5cdHRyYW5zcG9ydFR5cGVzWydwcm9jZXNzUmVtb3RlJ10gPSBmdW5jdGlvbiAodHlwZSwgc29ja2V0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IChkYXRhKSA9PiB7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdFx0XHR2YXIgcyA9IHNvY2tldC5zZW5kKFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoZGF0YSksXG5cdFx0XHRcdFx0XHQoZSkgPT4gZSBpbnN0YW5jZW9mIEVycm9yID8gcmVqKGUpIDogKHMgPT09IHRydWUgPyByZXMocykgOiByZWoocykpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0b25SZWN2OiAoZm4pID0+IHNvY2tldC5vbignbWVzc2FnZScsIChkYXRhKSA9PiBmbihKU09OLnBhcnNlKGRhdGEpKSksXG5cdFx0XHRzdG9wUmVjdjogKGZuKSA9PiBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcblx0XHR9XG5cdH07XG5cdHRyYW5zcG9ydFR5cGVzWydub2RlRUVSZW1vdGUnXSA9IGZ1bmN0aW9uICh0eXBlLCBzb2NrZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogKGRhdGEpID0+IHNvY2tldC5zZW5kKCdtZXNzYWdlJywgSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxuXHRcdFx0b25SZWN2OiAoZm4pID0+IHNvY2tldC5vbignbWVzc2FnZScsIChkYXRhKSA9PiBmbihKU09OLnBhcnNlKGRhdGEpKSksXG5cdFx0XHRzdG9wUmVjdjogKGZuKSA9PiBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcblx0XHR9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnRUeXBlcztcblxufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGVidWcpe1xuXG5cdHZhciBsb2dnZXIgPSBmdW5jdGlvbiAoc3VmZml4KSB7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5wcmVmaXggPSBzdWZmaXggfHwgJyc7XG5cblx0XHRpZih0eXBlb2YgZGVidWcgPT0gJ2Z1bmN0aW9uJyl7XG5cdFx0XHR0aGlzLmxvZyA9IGRlYnVnKGBsb2dzOmAgKyB0aGlzLnByZWZpeCk7XG5cdFx0XHR0aGlzLndhcm4gPSBkZWJ1Zyhgd2FybmluZ3M6YCArIHRoaXMucHJlZml4KTtcblx0XHRcdHRoaXMuZXJyb3IgPSBkZWJ1ZyhgZXJyb3JzOmAgKyB0aGlzLnByZWZpeCk7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNle1xuXHRcdFx0dGhpcy5sb2cgPSAoKT0+e307XG5cdFx0XHR0aGlzLndhcm4gPSAoKT0+e307XG5cdFx0XHR0aGlzLmVycm9yID0gKCk9Pnt9O1xuXHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGxvZ2dlci5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbiAoc3VmZml4KSB7XG5cdFx0cmV0dXJuIG5ldyBsb2dnZXIodGhpcy5wcmVmaXggKyAnOicgKyBzdWZmaXgpO1xuXHR9O1xuXG5cdHJldHVybiBsb2dnZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVidWcpIHtcblxuXHRjb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvbmFtZXNwYWNlLmpzJyk7XG5cdGNvbnN0IHJwY0VuZHBvaW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL3JwY0VuZHBvaW50LmpzJyk7XG5cdGNvbnN0IGRlYnVnciA9IHJlcXVpcmUoJ2RlYnVnLXBlc3QnKShkZWJ1Zyk7XG5cdHZhciBhcHBMb2dnZXIgPSBuZXcgZGVidWdyKCdvY3RvcHVzJyk7XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHR2YXIgcnBjcyA9IHt9O1xuXG5cdHZhciBycGMgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cblx0XHRpZiAob3B0aW9ucy5jcmVhdGUgPT09IHRydWUpIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLmNvbW1hbmRzID0ge307XG5cdFx0XHR0aGlzLmxvZ2dlciA9IGFwcExvZ2dlci5jaGlsZCh0aGlzLm5hbWUpO1xuXG5cdFx0XHR0aGlzLmluY29taW5nID0gbmV3IHJwY0VuZHBvaW50KG5hbWUsICdpJywgeyBsb2dnZXI6IHRoaXMubG9nZ2VyIH0pO1xuXHRcdFx0dGhpcy5vdXRnb2luZyA9IG5ldyBycGNFbmRwb2ludChuYW1lLCAnbycsIHsgbG9nZ2VyOiB0aGlzLmxvZ2dlciB9KTtcblxuXHRcdFx0dGhpcy5sb2dnZXIuZW5hYmxlZCAmJiB0aGlzLmxvZ2dlci5sb2coJ0NyZWF0ZWQgbmV3IE9jdG9wdXMgUlBDIGFzICcsIHRoaXMubmFtZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIXJwY3NbbmFtZV0pIHtcblx0XHRcdG9wdGlvbnMuY3JlYXRlID0gdHJ1ZTtcblx0XHRcdHJwY3NbbmFtZV0gPSBuZXcgcnBjKG5hbWUsIG9wdGlvbnMpO1xuXHRcdH1cblxuXG5cdFx0cmV0dXJuIHJwY3NbbmFtZV07XG5cblx0fTtcblx0cnBjLnByb3RvdHlwZS5kaXNwbGF5VHJhbnNwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuLS0tLS0tIFRyYW5zcG9ydHMgZm9yIFslc10gYXJlOlxcbicsIHRoaXMubmFtZSk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ2luY29taW5nOlxcbicpO1xuXHRcdC8vIHRoaXMuaW5jb21pbmcuZGlzcGxheVRyYW5zcG9ydHMoKTtcblx0XHQvLyBjb25zb2xlLmxvZygnXFxuXFxub3V0Z29pbmc6XFxuJyk7XG5cdFx0Ly8gdGhpcy5vdXRnb2luZy5kaXNwbGF5VHJhbnNwb3J0cygpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbicpO1xuXG5cdFx0dmFyIGxvZ1N0cmluZyA9IGBcblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0gVFJBTlNQT1JUUyBmb3IgWyR7dGhpcy5uYW1lfV0gYXJlIDogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkluY29taW5nIChwcm92aWRlcyk6XG5cbmA7XG5cblx0XHRsb2dTdHJpbmcgKz0gdGhpcy5pbmNvbWluZy5kaXNwbGF5U3RyaW5nKCk7XG5cdFx0bG9nU3RyaW5nICs9IGBcXG5cXG4tLS0tLS0tLS0tLS0tXFxuT3V0Z29pbmcgKGNhbGxzKTpcXG5cXG5gO1xuXHRcdGxvZ1N0cmluZyArPSB0aGlzLm91dGdvaW5nLmRpc3BsYXlTdHJpbmcoKTtcblx0XHRsb2dTdHJpbmcgKz0gJ1xcblxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbic7XG5cblx0XHRjb25zb2xlLmxvZyhsb2dTdHJpbmcpO1xuXHR9O1xuXG5cdHJwYy5wcm90b3R5cGUub3ZlciA9IGZ1bmN0aW9uIChzb2NrZXQsIHR5cGUpIHtcblx0XHR2YXIgdGFza3MgPSBbXTtcblx0XHR0YXNrcy5wdXNoKFxuXHRcdFx0dGhpcy5pbmNvbWluZy5vdmVyKHNvY2tldCwgdHlwZSlcblx0XHRcdC5hcyh0aGlzLm5hbWUpXG5cdFx0XHQuaW5pdFByb21pc2Vcblx0XHQpO1xuXHRcdHRhc2tzLnB1c2goXG5cdFx0XHR0aGlzLm91dGdvaW5nLm92ZXIoc29ja2V0LCB0eXBlKVxuXHRcdFx0LmFzUmVtb3RlKClcblx0XHRcdC5pbml0UHJvbWlzZVxuXHRcdCk7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKHRhc2tzKTtcblx0fTtcblx0cnBjLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG5cdFx0dGhpcy5pbmNvbWluZy5yZW1vdmUoc29ja2V0KTtcblx0XHR0aGlzLm91dGdvaW5nLnJlbW92ZShzb2NrZXQpO1xuXHR9O1xuXG5cdHJwYy5wcm90b3R5cGUucGx1Z2luVHJhbnNwb3J0cyA9IGZ1bmN0aW9uICh0T2JqKSB7XG5cdFx0dGhpcy5pbmNvbWluZy5wbHVnaW5UcmFuc3BvcnRzKHRPYmopO1xuXHRcdHRoaXMub3V0Z29pbmcucGx1Z2luVHJhbnNwb3J0cyh0T2JqKTtcblx0fTtcblx0cnBjLnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR2YXIgX3NlbGYgPSB0aGlzO1xuXHRcdGlmICghX3NlbGYuY29tbWFuZHNbbmFtZV0pIHtcblx0XHRcdHZhciBpQyA9IF9zZWxmLmluY29taW5nLmNvbW1hbmQobmFtZSk7XG5cdFx0XHR2YXIgb0MgPSBfc2VsZi5vdXRnb2luZy5jb21tYW5kKG5hbWUpO1xuXHRcdFx0X3NlbGYuTUVTU0FHRVRZUEVTID0gaUMuTUVTU0FHRVRZUEVTIHx8IG9DLk1FU1NBR0VUWVBFUztcblxuXHRcdFx0X3NlbGYuY29tbWFuZHNbbmFtZV0gPSB7XG5cdFx0XHRcdHByb3ZpZGU6IGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRcdGlDLnByb3ZpZGUoZm4pO1xuXHRcdFx0XHRcdHJldHVybiBfc2VsZi5jb21tYW5kc1tuYW1lXTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dW5Qcm92aWRlOiBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdFx0XHRpQy51blByb3ZpZGUoZm4pO1xuXHRcdFx0XHRcdHJldHVybiBfc2VsZi5jb21tYW5kc1tuYW1lXTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25Qcm92aWRlOiBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdFx0XHRpQy5vblByb3ZpZGUoZm4pO1xuXHRcdFx0XHRcdHJldHVybiBfc2VsZi5jb21tYW5kc1tuYW1lXTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2FsbDogZnVuY3Rpb24gKGZpbHRlciwgZGF0YSkge1xuXHRcdFx0XHRcdC8vIF9zZWxmLmRpc3BsYXlUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIG9DLmNhbGwoZmlsdGVyLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY29tbWFuZHNbbmFtZV07XG5cdH07XG5cdHJwYy5wcm90b3R5cGUucmVuYW1lVG8gPSBmdW5jdGlvbiAobmV3TmFtZSkge1xuXHRcdHRoaXMuaW5jb21pbmcucmVuYW1lKHRoaXMubmFtZSlcblx0XHRcdC5hcyhuZXdOYW1lKTtcblx0XHR0aGlzLm5hbWUgPSBuZXdOYW1lO1xuXHRcdC8vIHRoaXMub3V0Z29pbmcubGFiZWwgPSBuZXdOYW1lO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLSAgUmVzdWx0IHBhcnNpbmcgJiBSZXNvbHZpbmcgdG8gUHJvbWlzZSByZXNvbHZlL3JlamVjdCAtLS0tLS0tLS0tLSovXG5cblx0cnBjLnByb3RvdHlwZS5wYXJzZUJ5U3RhdHVzID0gZnVuY3Rpb24gKHJlcykge1xuXHRcdHZhciB2YWxpZHMgPSBbXSxcblx0XHRcdGludmFsaWRzID0gW10sXG5cdFx0XHRjaGVjaztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2hlY2sgPSByZXNbaV07XG5cdFx0XHRpZiAoY2hlY2suc2VudCA9PT0gdHJ1ZSAmJiBjaGVjay5zdGF0dXMgPT09IHRydWUpXG5cdFx0XHRcdHZhbGlkcy5wdXNoKGNoZWNrKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0aW52YWxpZHMucHVzaChjaGVjayk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR2YWxpZHM6IHZhbGlkcyxcblx0XHRcdGludmFsaWRzOiBpbnZhbGlkc1xuXHRcdH07XG5cdH07XG5cblx0cnBjLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHApIHtcblx0XHRpZiAocC5zZW50ID09PSB0cnVlICYmIHAuc3RhdHVzID09PSB0cnVlKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShwLnJlc3BvbnNlKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QocC5yZXNwb25zZSk7XG5cdH07XG5cdHJwYy5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIChwKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChwW2ldLnNlbnQgPT09IGZhbHNlIHx8IHBbaV0uc3RhdHVzID09PSBmYWxzZSlcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHApO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocCk7XG5cdH07XG5cdHJwYy5wcm90b3R5cGUucmVzb2x2ZUF0TGVhc3RPbmUgPSBmdW5jdGlvbiAocCkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocFtpXS5zZW50ID09PSB0cnVlICYmIHBbaV0uc3RhdHVzID09PSB0cnVlKVxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHApO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChwKTtcblx0fTtcblxuXG5cblxuXHRyZXR1cm4gcnBjO1xuXG59O1xuIl19"}