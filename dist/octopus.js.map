{"version":3,"sources":["node_modules/browser-pack/_prelude.js","components/namespace.js","components/rpcCommand.js","components/rpcEndpoint.js","components/rpcTransport.js","components/stockTransports.js","node_modules/debug-pest/index.js","octopus.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"octopus.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function () {\n\n\t/* ------\n\t\n\t\tCode below is adapted from the debug library, duly licensed as below.\n\n\t\t(The MIT License)\n\n\t\tCopyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy of this software\n\t\tand associated documentation files (the 'Software'), to deal in the Software without restriction,\n\t\tincluding without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t\tand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n\t\tsubject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all copies or substantial\n\t\tportions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT\n\t\tLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\t\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\t\tWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\t\tSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\t------ */\n\n\tvar Namespace = function (namespaces) {\n\n\t\tthis.names = [];\n\t\tthis.skips = [];\n\n\t\tvar i;\n\t\tvar split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tvar len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) continue; // ignore empty strings\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tthis.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tthis.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\n\t\treturn this;\n\t};\n\n\n\tNamespace.prototype.test = function (value) {\n\t\tvar i, len;\n\n\t\tfor (i = 0, len = this.skips.length; i < len; i++) {\n\t\t\tif (!this.skips[i].test(value))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, len = this.names.length; i < len; i++) {\n\t\t\tif (this.names[i].test(value))\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\n\tmodule.exports = Namespace;\n\n})();\n","(function () {\n\n\tconst Namespace = require('./namespace.js');\n\n\n\n\t/* ----------------------------------------------------------- */\n\n\n\tconst MESSAGETYPES = {\n\t\trequest: 'RQ',\n\t\tresponseAccept: 'RA',\n\t\tresponseFail: 'RF',\n\t\tresponseAcceptError: 'RAE',\n\t\tresponseFailError: 'RFE'\n\t};\n\n\n\tvar rpcCommand = function (name, endpoint, options) {\n\t\toptions = options || {};\n\t\t// console.log('Creating rpc command [%s] for endpoint [%s][%s]',name, endpoint.label, endpoint.dir);\n\t\tthis.name = name;\n\t\tthis.endpoint = endpoint;\n\t\tthis.requestHandlers = [];\n\t\tthis.responseHandlers = {};\n\t\tthis.onProvideFn = null;\n\t\tthis.endpoint.commands[name] = this;\n\n\t\tthis.logger = options.logger.child('CMD:' + this.name);\n\t\tthis.sendLogger = this.logger.child('send');\n\t\tthis.recvLogger = this.logger.child('recv');\n\t\tthis.logger.enabled && this.logger.log('Created new command as ', name);\n\n\t\tthis.MESSAGETYPES = MESSAGETYPES;\n\t\treturn this;\n\t};\n\n\n\trpcCommand.prototype.autoID = function () {\n\t\treturn Math.random().toString().substr(8) + '-' + Date.now();\n\t};\n\n\trpcCommand.prototype.sendToID = function (tid, msg, mode, pTransName) {\n\t\tvar _self = this;\n\n\t\tmsg.msgID = _self.autoID();\n\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n[sendToID] called with tid[%s], msgID[%s], mode[%s], pTransName[%s] \\n', tid, msg.msgID, mode, pTransName);\n\n\t\t/*\n\t\t\tNOTE - Adding a check as a hotfix to avoind crashing on tName errors.\n\n\t\t\tSource of errors - sendToID is called from call() as well as recursively, when responding to messages.\n\n\t\t\tThe source of tName errors may be the async nature. Since this is async, there's a gap in between call & execution\n\t\t\tbetween which a \"remove()\" function call might delete the transport, raising such issues.\n\n\t\t\tCase #1 - Deleted transport after a call from .call(), but before the execution of sendToID, causing tName errors.\n\t\t\tCase #2 - Alternately, Deleted the transport after a message was recieved, but before a response could be sent.\n\n\t\t\tNOTE - EDGE CASE TO SOLVE :\n\t\t\tWhat happens if in either case, the response is critical for proper function / avoiding duplication of calls (see below),\n\t\t\tand could be sent because the reciever still exists (ie same tName), but over a different transport (ie different tID).\n\n\t\t\tHow duplication of calls -\n\t\t\t\tSender sends RPC\n\t\t\t\tReciever gets RPC & executes provider\n\t\t\t\tSender disconnects & reconnects with a new connection\n\t\t\t\tReciever removes previous socket & re-adds new socket (ie same tName, once initial handshake is done, but different tID).\n\t\t\t\tReciever RPC call response fails / ignored because old tID doesn't exist anymore.\n\t\t\t\tSender times out (or considers failure due to disconnection / remains hanging as a memory leak), even though RPC provider has executed on reciever\n\t\t\t\tApplication tries again assuming bad RPC call.\n\n\t\t\tPossible solution -\n\t\t\t\tif tID mismatch is found,\n\t\t\t\t\ta search of other transports with the same tName is done,\n\t\t\t\t\t \tif found, send as usual and resolve\n\t\t\t\t\t\tif not found,\n\t\t\t\t\t\t\tcall is hooked and waits till another transport with the same name connects before timeout\n\t\t\t\t\t\t\tif connects,\n\t\t\t\t\t\t\t\tsend as usual & resolve\n\t\t\t\t\t\t\tif not,\n\t\t\t\t\t\t\t\tfail with a timeout\n\t\t*/\n\n\t\tif (tid === '' || !_self.endpoint.transports[tid]) {\n\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n[sendToID] transport to tid[%s] does not exist. Taking corrective action... \\n', tid);\n\n\n\t\t\tvar trans = _self.endpoint.findTransportByName(pTransName);\n\n\t\t\t// If found, continue with discovered transport\n\t\t\tif (trans) {\n\t\t\t\ttid = trans.id;\n\t\t\t}\n\n\t\t\t// Else wait for a new transport to connect, or reject on timeout\n\t\t\telse {\n\t\t\t\treturn Promise.resolve()\n\n\t\t\t\t\t// Wait for new transport with given name to setup\n\t\t\t\t\t.then(() => _self.endpoint.addTransportNameChangeHook(pTransName))\n\n\t\t\t\t\t// Once hook fires, call this recursively and try to resend\n\t\t\t\t\t.then((t) => this.sendToID(t.id, msg, mode, pTransName))\n\n\t\t\t\t\t// Reject if it fails (worst case situation)\n\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.warn('[ERROR] transport tName[%s] was not found as tid[%s]. Might lead to duplicated provider executions, if re-connections caused it.', tName, tid);\n\n\t\t\t\t\t\tif (!mode || mode != 'respond') {\n\t\t\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.warn('Cannot call - missing transport');\n\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\tsent: false,\n\t\t\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\t\t\ttransport: pTransName,\n\t\t\t\t\t\t\t\tcommand: _self.name,\n\t\t\t\t\t\t\t\tresponse: 'transport removed or changed'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.warn('Cannot respond - missing transport');\n\t\t\t\t\t\t\treturn Promise.reject('transport missing');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// NOTE - In case the tName has changed since the call\n\t\tvar tName = _self.endpoint.transports[tid].tName;\n\n\t\tmsg.source = _self.endpoint.label;\n\t\t_self.sendLogger.enabled && _self.sendLogger.log('Sending on transport [%s][%s], mode = %s,  msg =', tid, tName, mode, msg);\n\n\n\t\tif (!mode || mode != 'respond') {\n\n\t\t\treturn new Promise((res, rej) => {\n\n\t\t\t\tvar sent = false;\n\n\t\t\t\t// handler function\n\t\t\t\tvar handler = function (respData, msgType) {\n\t\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\nResponse handler called with respData & msgTypes as \\n', respData, msgType);\n\n\t\t\t\t\tdelete _self.responseHandlers[tName][msg.msgID];\n\n\n\t\t\t\t\tswitch (msgType) {\n\n\t\t\t\t\tcase MESSAGETYPES.responseAccept:\n\t\t\t\t\t\tres({\n\t\t\t\t\t\t\tsent: sent,\n\t\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\t\ttransport: tName,\n\t\t\t\t\t\t\tcommand: _self.name,\n\t\t\t\t\t\t\tresponse: respData\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MESSAGETYPES.responseFail:\n\t\t\t\t\t\tres({\n\t\t\t\t\t\t\tsent: sent,\n\t\t\t\t\t\t\tstatus: false,\n\t\t\t\t\t\t\ttransport: tName,\n\t\t\t\t\t\t\tcommand: _self.name,\n\t\t\t\t\t\t\tresponse: respData\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\n\t\t\t\tif (!_self.responseHandlers[tName])\n\t\t\t\t\t_self.responseHandlers[tName] = {};\n\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\nAdding response handler at [%s][%s] \\n', tName, msg.msgID);\n\t\t\t\t_self.responseHandlers[tName][msg.msgID] = handler;\n\n\n\t\t\t\tvar container = {\n\t\t\t\t\trpc_msg: {},\n\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t};\n\t\t\t\tcontainer.rpc_msg[_self.name] = msg;\n\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n\\nSending %s to [%s] as \\n', mode == 'respond' ? 'response' : 'request', tName, container);\n\t\t\t\tPromise.resolve(_self.endpoint.transports[tid].send(container))\n\t\t\t\t\t.then((s) => sent = true)\n\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\tsent = false;\n\t\t\t\t\t\thandler(e, MESSAGETYPES.responseFail);\n\t\t\t\t\t});\n\n\t\t\t});\n\t\t} else {\n\n\t\t\tvar container = {\n\t\t\t\trpc_msg: {},\n\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t};\n\t\t\tcontainer.rpc_msg[_self.name] = msg;\n\n\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('\\n\\n\\nSending %s to [%s] as \\n', mode == 'respond' ? 'response' : 'request', tName, container);\n\t\t\treturn Promise.resolve(_self.endpoint.transports[tid].send(container));\n\t\t}\n\t};\n\n\t/*\n\t\tData can be a value or a function.\n\t\tIf its a function, it will be evaluated for every new transport\n\n\t\tand passed params as:\n\t\t\t1. the transport tName, index - if found.\n\t\t\t2. null, null - if no transports are found, and it goes to waiting\n\n\t\t//TODO - improve consistency in params passed to data function.\n\n\t*/\n\trpcCommand.prototype.call = function (namespace, data, mode) {\n\t\tvar _self = this;\n\t\tvar tName;\n\t\tvar tasks = [];\n\t\tvar evaluate = false;\n\n\n\t\tif (typeof data === 'function') {\n\t\t\tevaluate = true;\n\t\t}\n\n\t\t// Send to all transports that match the namespace\n\t\tvar tasks = _self.endpoint.findTransportsByNamespace(namespace, { initialised: true })\n\t\t\t.map((t, i) => {\n\t\t\t\tvar msg = {\n\t\t\t\t\tmsgID: _self.autoID(),\n\t\t\t\t\tmsgType: MESSAGETYPES.request,\n\t\t\t\t\treqData: evaluate === true ? data(t.tName, i) : data,\n\t\t\t\t};\n\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('Transport [%s] is valid. Attempting to send', t.id);\n\n\t\t\t\treturn _self.sendToID(t.id, msg, mode, t.tName);\n\t\t\t});\n\n\n\t\t// If transports were not found,\n\t\t// hook & wait for the first valid transport that connects\n\t\tif (tasks.length == 0){\n\n\t\t\tvar msg = {\n\t\t\t\tmsgID: _self.autoID(),\n\t\t\t\tmsgType: MESSAGETYPES.request,\n\t\t\t\treqData: evaluate === true ? data(null, null) : data,\n\t\t\t};\n\n\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('No transports found for [%s]. Waiting', namespace);\n\n\t\t\treturn Promise.all([_self.sendToID('', msg, mode, namespace)]);\n\n\t\t}\n\n\t\t// Otherwise, wait till all messages have been sent & resolve.\n\t\telse\n\t\t\treturn Promise.all(tasks);\n\n\n\t};\n\n\t// rpcCommand.prototype.call = function (namespaceString, data) {\n\t// \tvar _self = this;\n\t//\n\t// \tvar msg = {\n\t// \t\tmsgID: _self.autoID(),\n\t// \t\tmsgType: MESSAGETYPES.request,\n\t// \t\treqData: data,\n\t// \t};\n\t//\n\t//\n\t// \t_self.sendLogger.enabled && _self.sendLogger.log('Requesting RPC with msg = ', msg);\n\t// \treturn _self.send(namespaceString, msg);\n\t//\n\t// };\n\n\n\trpcCommand.prototype.recieve = function (msg, transport) {\n\t\tvar _self = this;\n\t\tvar tName = transport.tName,\n\t\t\ttid = transport.id;\n\n\t\t_self.recvLogger.enabled && _self.recvLogger.log('\\n\\n\\nCommand [%s] Data recvd on [%s][%s] as \\n', _self.name, _self.endpoint.label, _self.endpoint.dir, tName, msg);\n\n\t\tswitch (msg.msgType) {\n\t\tcase MESSAGETYPES.responseAccept:\n\t\tcase MESSAGETYPES.responseFail:\n\t\t\t// console.log('\\n\\n\\nResponse recvd on [%s] from [%s] as\\n ',tName, msg.rtName, msg);\n\t\t\tif (_self.responseHandlers[tName] && _self.responseHandlers[tName][msg.respID]) {\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('handler found. Responding !');\n\t\t\t\treturn Promise.resolve(_self.responseHandlers[tName][msg.respID](msg.respData, msg.msgType));\n\n\t\t\t} else {\n\t\t\t\t_self.sendLogger.enabled && _self.sendLogger.log('handler not found');\n\t\t\t\treturn Promise.reject(new Error('handler not found'));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MESSAGETYPES.request:\n\t\t\t// console .log('\\n\\nCommand[%s] Request recvd on [%s] as\\n ',_self.name, tName,msg);\n\n\t\t\tif (_self.requestHandlers.length > 0) {\n\t\t\t\t// console.log('\\n[%s]Request handlers found\\n ',_self.requestHandlers.length);\n\n\t\t\t\tvar chain = Promise.resolve();\n\t\t\t\tvar reqData = msg.reqData;\n\n\t\t\t\t_self.requestHandlers.forEach((h) => {\n\t\t\t\t\t/* Each handler is called with (v,p,s,t,msg) as follows\n\t\t\t\t\t\tv\t= reqData \t- data sent by caller,\n\t\t\t\t\t\tp\t= prev\t\t- response got from the prevhandler's execution for this call,\n\t\t\t\t\t\ts \t= msg.source \t- name of the calling transport (this was the actual usecase for tName ?)\n\t\t\t\t\t\tt\t= tName \t\t- name of current transport (TODO - buggy, points to local transport name)\n\t\t\t\t\t\tmsg \t= msg \t\t- full raw msg obj\n\t\t\t\t\t*/\n\t\t\t\t\tchain = chain.then((prev) => h(msg.reqData, prev, msg.source, tName, msg));\n\t\t\t\t});\n\t\t\t\treturn chain\n\t\t\t\t\t.then((respData) => {\n\t\t\t\t\t\t// console.log('\\nRequest handlers SUCCESS\\n Results are',respData);\n\n\t\t\t\t\t\tmsg.respID = msg.msgID;\n\t\t\t\t\t\tmsg.rtName = tName;\n\t\t\t\t\t\tmsg.msgID = _self.autoID();\n\t\t\t\t\t\tmsg.msgType = MESSAGETYPES.responseAccept;\n\t\t\t\t\t\tmsg.respData = respData;\n\t\t\t\t\t\tdelete msg.reqData;\n\t\t\t\t\t\treturn _self.sendToID(tid, msg, 'respond', tName);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t// console.log('\\nRequest handlers FAILED\\n Results are',e);\n\n\t\t\t\t\t\tmsg.respID = msg.msgID;\n\t\t\t\t\t\tmsg.rtName = tName;\n\t\t\t\t\t\tmsg.msgID = _self.autoID();\n\t\t\t\t\t\tmsg.msgType = MESSAGETYPES.responseFail;\n\t\t\t\t\t\tmsg.respData = e;\n\t\t\t\t\t\tdelete msg.reqData;\n\t\t\t\t\t\treturn _self.sendToID(tid, msg, 'respond', tName);\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => _self.onProvideFn ? _self.onProvideFn(reqData, msg.respData, tName, msg) : null)\n\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\tconsole.error('[Octopus] Error while executing [%s] provider chain on [%s] - ', _self.name, tName, e);\n\t\t\t\t\t\treturn Promise.reject(e);\n\t\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\t_self.recvLogger.enabled && _self.recvLogger.error('ERROR - No requestHandlers for command[%s] on [%s][%s] -  tName, msg - ', _self.name, _self.endpoint.label, _self.endpoint.dir, tName, msg);\n\t\t\t\tmsg.respID = msg.msgID;\n\t\t\t\tmsg.rtName = tName;\n\t\t\t\tmsg.msgID = _self.autoID();\n\t\t\t\tmsg.msgType = MESSAGETYPES.responseFail;\n\t\t\t\tmsg.respData = 'no providers';\n\t\t\t\tdelete msg.reqData;\n\t\t\t\treturn _self.sendToID(tid, msg, 'respond', tName);\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t};\n\n\trpcCommand.prototype.provide = function (fn) {\n\t\tif (typeof fn == \"function\")\n\t\t\tthis.requestHandlers.push(fn);\n\t\telse {\n\t\t\tthrow new Error('Param passed to \"provide\" is not a function');\n\t\t}\n\t};\n\n\trpcCommand.prototype.unProvide = function (fn) {\n\t\tvar index = this.requestHandlers.findIndex((x) => x === fn);\n\t\tif (index > -1)\n\t\t\tthis.requestHandlers.splice(index, 1);\n\t\treturn this;\n\t};\n\n\t/*\n\t\tExecutes passed fn when provide response is successfully recieved by remote.\n\t\t\tAssuming transport send() function returns a promise on successfull\n\t\t\ttransfer of response message\n\t*/\n\trpcCommand.prototype.onProvide = function (fn) {\n\t\tif (typeof fn == \"function\")\n\t\t\tthis.onProvideFn = fn;\n\t\telse {\n\t\t\tthrow new Error('Param passed to \"onProvideFn\" is not a function');\n\t\t}\n\t};\n\n\n\n\t/* ----------------------------------------------------------- */\n\n\n\tmodule.exports = rpcCommand;\n\n})();\n","(function () {\n\n\tconst Namespace = require('./namespace.js');\n\tconst rpcStockTransports = require('./stockTransports.js');\n\tconst rpcTransport = require('./rpcTransport.js');\n\tconst rpcCommand = require('./rpcCommand.js');\n\t/* ----------------------------------------------------------- */\n\n\n\tvar rpcEndpoint = function (l, dir, options) {\n\t\toptions = options || {};\n\t\tthis.logger = options.logger.child(dir == 'i' ? 'EP:in' : 'EP:out');\n\n\n\t\tthis.transports = {};\n\t\tthis.nameChangeHooks = {};\n\t\tthis.label = l;\n\t\tthis.dir = dir;\n\t\tthis.commands = {};\n\t\tthis.transportTypes = rpcStockTransports;\n\n\t\tthis.logger.enabled && this.logger.log('Created new endpoint as [%s][%s]', l, dir);\n\n\t\treturn this;\n\t};\n\n\trpcEndpoint.prototype.pluginTransports = function (tColl) {\n\t\tthis.transportTypes = Object.assign(this.transportTypes, tColl);\n\t};\n\n\trpcEndpoint.prototype.over = function (socket, type) {\n\t\treturn new rpcTransport(type, socket, this, { logger: this.logger });\n\t};\n\trpcEndpoint.prototype.remove = function (socket) {\n\t\tvar _self = this;\n\t\t// Object.keys(_self.transports).forEach((tid) => {\n\t\t// \tif (_self.transports[tid].socket == socket){\n\t\t// \t\t_self.logger.enabled && _self.logger.log('Destroying & removing transport [%s] tName [%s]. ',tid,_self.transports[tid].tName);\n\t\t// \t\t_self.transports[tid].destroy();\n\t\t// \t\tdelete _self.transports[tid];\n\t\t// \t}\n\t\t// });\n\n\t\t// _self.logger.enabled && _self.logger.log('Attempting to remove socket. ',socket._octopus);\n\t\t// _self.logger.enabled && _self.logger.log('Current endpoint[%s][%s] transports are . ',_self.label, _self.dir, _self.transports);\n\n\t\tif (socket && socket._octopus && socket._octopus.transports) {\n\n\t\t\t// Go through transports added to socket\n\t\t\tsocket._octopus.transports.forEach((t) => {\n\n\t\t\t\t// See if its a transport of this endpoint\n\t\t\t\tvar foundT = Object.keys(_self.transports).find(x => _self.transports[x] === t);\n\n\t\t\t\t// if found, disassociate from socket, destroy and delete from endpoint\n\t\t\t\tif (foundT) {\n\t\t\t\t\tfoundT = _self.transports[foundT];\n\t\t\t\t\t_self.logger.enabled && _self.logger.warn('Destroying & removing transport [%s] tName [%s] from endpoint[%s][%s]. ', foundT.id, foundT.tName, _self.label, _self.dir);\n\n\t\t\t\t\tvar index = socket._octopus.transports.findIndex(x => x == t);\n\t\t\t\t\tsocket._octopus.transports.splice(index, 1);\n\n\n\t\t\t\t\tfoundT.destroy();\n\t\t\t\t\tdelete _self.transports[foundT.id];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\trpcEndpoint.prototype.rename = function (namespace) {\n\n\t\t/*\n\t\t\tNOTE - Must investigate if there are side effects ?\n\n\t\t\tShould we be allowed to change remote side name ?\n\t\t\t\tAny usecase where we need it ?\n\n\t\t\tIf our name change is accepted by remote side,\n\t\t\t \tshould it trigger name changes with other connected transports too ? since there can only be one name for the remote.\n\n\t\t\tIf we change the remote's name,\n\t\t\t\tshould it trigger name changes with other connected transports too ? since there can only be one name for the remote.\n\n\t\t\tIf so,\n\t\t\t\tCould this cause infinite loops / ripples ?\n\n\t\t\tFor eg - Say connection path is setup as\n\t\t\t\tA - B - C - D - A\n\t\t\t\t    |_______|\n\n\t\t*/\n\t\tvar _self = this;\n\t\tnamespace = new Namespace(namespace);\n\t\treturn {\n\t\t\tas: (newName) => {\n\t\t\t\t_self.label = newName;\n\t\t\t\tObject.keys(_self.transports).forEach((tid) => {\n\t\t\t\t\tif (namespace.test(_self.transports[tid].tName)) {\n\t\t\t\t\t\t_self.transports[tid].as(newName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t};\n\n\t/*\n\t \tInternal hook called by transport, to signal a name change\n\t\t& Automatically cleans up after it executes once (resolve or reject).\n\t*/\n\trpcEndpoint.prototype.transportNameChanged = function (transport) {\n\n\t\t/*\n\t\t\tNOTE - Including both exact & NS match, for performance.\n\t\t\tthis ensures that any exact match is quickly detected and resolved first,\n\t\t\tcausing one less regex match transaction (more expensive) in the subsequent routine.\n\t\t*/\n\n\t\t// Run all hooks whose namespace exactly matches transport's tName\n\t\tif (this.nameChangeHooks[transport.tName]) {\n\t\t\tthis.nameChangeHooks[transport.tName].hooks.forEach(x => x(transport));\n\t\t\tdelete this.nameChangeHooks[transport.tName];\n\t\t}\n\n\t\t// Also, run all hooks whose namespace includes the transport's tName\n\t\tObject.keys(this.nameChangeHooks).map(k => {\n\t\t\tif (this.nameChangeHooks[k] && this.nameChangeHooks[k].ns.test(transport.tName)) {\n\t\t\t\tthis.nameChangeHooks[k].hooks.forEach(x => x(transport));\n\t\t\t\tdelete this.nameChangeHooks[k];\n\t\t\t}\n\t\t})\n\t};\n\n\t/*\n\t\tReturns a one-time hook promise that\n\t\t\t1> resolves when appropriate name change occurs\n\t\t\t2> rejects if timeout happens\n\n\t\t& Automatically cleans up if it rejects (times out).\n\t\tClean up on resolve is handled by triggering routine declared above.\n\t*/\n\trpcEndpoint.prototype.addTransportNameChangeHook = function (tName, timeout) {\n\t\tif (!this.nameChangeHooks[tName])\n\t\t\tthis.nameChangeHooks[tName] = {\n\t\t\t\tns: new Namespace(tName),\n\t\t\t\thooks: []\n\t\t\t};\n\n\t\tvar p = new Promise((res, rej) => {\n\t\t\tvar fn = (transport) => {\n\t\t\t\tif (res && !p.done) {\n\t\t\t\t\tp.done = true;\n\t\t\t\t\t// var i = this.nameChangeHooks[tName].hooks.findIndex(x => x == fn);\n\t\t\t\t\t// this.nameChangeHooks[tName].hooks.splice(i, 1);\n\t\t\t\t\tres(transport);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.nameChangeHooks[tName].hooks.push(fn);\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (rej && !p.done) {\n\t\t\t\t\tp.done == true;\n\t\t\t\t\tvar i = this.nameChangeHooks[tName].hooks.findIndex(x => x == fn);\n\t\t\t\t\tthis.nameChangeHooks[tName].hooks.splice(i, 1);\n\t\t\t\t\tif (this.nameChangeHooks[tName].hooks.length == 0) {\n\t\t\t\t\t\tdelete this.nameChangeHooks[tName];\n\t\t\t\t\t}\n\t\t\t\t\trej();\n\t\t\t\t}\n\t\t\t}, timeout || 5000);\n\n\t\t});\n\n\t\treturn p;\n\t};\n\n\trpcEndpoint.prototype.displayString = function () {\n\t\tvar _self = this;\n\t\tvar logString = 'key\\t\\t\\tname\\t\\t\\ttype:id\\t\\t\\tinitalised\\n';\n\t\tObject.keys(_self.transports).forEach((tKey) => {\n\t\t\tlogString += `${tKey}\\t\\t${_self.transports[tKey].tName}\\t\\t${_self.transports[tKey].type +':'+_self.transports[tKey].id}\\t\\t${_self.transports[tKey].initialised}\\n`;\n\t\t});\n\t\treturn logString;\n\t};\n\n\trpcEndpoint.prototype.command = function (name) {\n\t\treturn new rpcCommand(name, this, { logger: this.logger });\n\t};\n\n\t// Returns the first transport that's an exact match by tName\n\trpcEndpoint.prototype.findTransportByName = function (tName) {\n\t\tvar tKey = Object.keys(this.transports).find(x => this.transports[x].tName == tName);\n\n\t\tif (tKey)\n\t\t\treturn this.transports[tKey];\n\t\telse\n\t\t\treturn null;\n\t};\n\n\t// Returns all transports that fall within a given namespace\n\trpcEndpoint.prototype.findTransportsByNamespace = function (namespace, options) {\n\t\toptions = options || {}\n\t\tvar ns = new Namespace(namespace);\n\t\tvar transports = Object.keys(this.transports)\n\t\t\t.map(x => this.transports[x]);\n\n\n\t\tif (options.intialised === true) {\n\t\t\ttransports = transports.filter(t => t.initialised === true)\n\t\t}\n\n\t\treturn transports\n\t\t\t.filter(t => ns.test(t.tName))\n\n\t};\n\n\t/* ----------------------------------------------------------- */\n\n\n\tmodule.exports = rpcEndpoint;\n\n})();\n","(function () {\n\tvar idCount = 0;\n\tvar autoID = function () {\n\t\treturn 'T' + (++idCount);\n\t};\n\n\tvar rpcTransport = function (type, socket, endpoint, options) {\n\t\t// console.log('Creating rpc transport [%s] for endpoint [%s][%s]',type, endpoint.label, endpoint.dir);\n\t\toptions = options || {};\n\t\tvar _self = this;\n\n\t\t_self.id = autoID();\n\t\t_self.logger = options.logger.child('T:' + type + ':' + _self.id);\n\n\t\t_self.endpoint = endpoint;\n\t\t_self.type = type;\n\t\t_self.socket = socket; // Also used for matching & removal, besides internal socket access.\n\t\t_self.tName = 'nonname';\n\t\t_self.initialised = false;\n\t\t_self.disabled = false;\n\t\t_self.nameClock = 0;\n\t\t_self.dirFlip = {\n\t\t\ti: 'o',\n\t\t\to: 'i'\n\t\t};\n\n\t\t// Add trasport type specific methods to self\n\t\tObject.assign(_self, _self.endpoint.transportTypes[type](type, socket));\n\t\tif(!socket._octopus)\n\t\t\tsocket._octopus = {};\n\n\t\tif(!socket._octopus.transports)\n\t\t\tsocket._octopus.transports = [];\n\n\t\tif(!socket._octopus.transports.includes(this))\n\t\t\tsocket._octopus.transports.push(this);\n\n\t\t_self.initPromise = new Promise((res, rej) => {\n\t\t\t_self.recvHandler = function (data) {\n\n\t\t\t\t// Abort if we're disabled\n\t\t\t\tif(_self.disabled)\n\t\t\t\t\treturn;\n\n\n\t\t\t\t// _self.logger.enabled && _self.logger.log('[onRecv] Data recvd on [%s][%s]',_self.tName,_self.endpoint.dir, data);\n\t\t\t\tif (data.rpc_dir == _self.dirFlip[_self.endpoint.dir]) {\n\t\t\t\t\t// console.log('[onRecv] Data accepted on [%s][%s]',_self.tName,_self.endpoint.dir, data);\n\n\t\t\t\t\tif (data.rpc_tName_change) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tNOTE - Implementing \"Latest & last write wins\" consensus policy :\n\t\t\t\t\t\t\t\tWHY ? - Required to solve disputes when both(or more) endpoints request a name change at the same time.\n\t\t\t\t\t\t\t\tWithout this, a simultaneous request causes each one to sends his name change over while implementing the other's name change request.\n\t\t\t\t\t\t\t\t \tconsequence - a name swap, instead of consensus on a single name value.\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tif(data.rpc_tName_change.request == true){\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOpposite party has requested a name change transaction, to be initiated from here.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('Name change requested by remote. Initiating transaction...',_self.tName);\n\n\t\t\t\t\t\t\t_self.as(_self.tName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (data.rpc_tName_change.ack == true) {\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOpposite party has accepted the name change that we proposed.\n\t\t\t\t\t\t\t\tHurray. Signal namechange to endpoint & resolve.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('Name change to [%s] acknowledged.',_self.tName);\n\n\t\t\t\t\t\t\t_self.endpoint.transportNameChanged(_self);\n\n\t\t\t\t\t\t\tif (!_self.initialised) {\n\t\t\t\t\t\t\t\t_self.initialised = true;\n\t\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('changed initialised status from false to true');\n\t\t\t\t\t\t\t\tres();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (data.rpc_tName_change.force || data.rpc_tName_change.clock >= _self.nameClock) {\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOpposite party's clock is higher or has already reached the same level (ie before us).\n\t\t\t\t\t\t\t\tAccept their proposal, send ack, signal namechange to endpoint\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('[%s, clock %s] [%s] Changing name of transport [%s][%s] to [%s] at clock =', _self.endpoint.label, _self.nameClock, data.rpc_tName_change.force ? 'forced' : '', _self.tName, _self.id, data.rpc_tName_change.tName, data.rpc_tName_change.clock);\n\t\t\t\t\t\t\t// delete _self.endpoint.transports[_self.tName];\n\t\t\t\t\t\t\t_self.tName = data.rpc_tName_change.tName;\n\t\t\t\t\t\t\t_self.nameClock = data.rpc_tName_change.clock;\n\t\t\t\t\t\t\t// _self.endpoint.transports[_self.tName] = _self;\n\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('Name change to [%s] accepted.',_self.tName);\n\n\t\t\t\t\t\t\t// Send ack\n\t\t\t\t\t\t\t_self.send({\n\t\t\t\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\t\t\t\ttName: _self.tName,\n\t\t\t\t\t\t\t\t\tclock: _self.nameClock,\n\t\t\t\t\t\t\t\t\tack: true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t_self.endpoint.transportNameChanged(_self);\n\n\t\t\t\t\t\t\tif (!_self.initialised) {\n\t\t\t\t\t\t\t\t_self.initialised = true;\n\t\t\t\t\t\t\t\tres();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tOur clock is higher, so don't accept.\n\t\t\t\t\t\t\t\tPropose our name instead.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.log('[%s, clock %s] [%s] Rejecting name change of transport [%s][%s] as [%s] at clock =', _self.endpoint.label, _self.nameClock, data.rpc_tName_change.force ? 'forced' : '', _self.tName, _self.id, data.rpc_tName_change.tName, data.rpc_tName_change.clock);\n\t\t\t\t\t\t\t_self.send({\n\t\t\t\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\t\t\t\ttName: _self.tName,\n\t\t\t\t\t\t\t\t\tclock: _self.nameClock,\n\t\t\t\t\t\t\t\t\tforce: true\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.rpc_msg) {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tObject.keys(data.rpc_msg).forEach((cKey) => {\n\n\t\t\t\t\t\t\tif (_self.endpoint.commands[cKey]){\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t// _self.logger.enabled && _self.logger.log('[onRecv] Data recvd on [%s][%s]',_self.tName,_self.endpoint.dir, data);\n\t\t\t\t\t\t\t\t_self.endpoint.commands[cKey].recieve(data.rpc_msg[cKey], _self)\n\t\t\t\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.error('[%s] Failed to respond to [%s] request (registered) from [%s] because -  ', _self.endpoint.label, cKey, _self.tName);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t// Create a temp command and process.\n\t\t\t\t\t\t\t\t_self.endpoint.command(cKey).recieve(data.rpc_msg[cKey], _self)\n\t\t\t\t\t\t\t\t.catch((e) => {\n\t\t\t\t\t\t\t\t\t_self.logger.enabled && _self.logger.error('[%s] Failed to respond to [%s] request (temporary) from [%s] because -  ', _self.endpoint.label, cKey, _self.tName);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t_self.onRecv(_self.recvHandler);\n\n\t\t\t_self.destroy = function(){\n\t\t\t\t// _self.logger.enabled && _self.logger.log('[%s] Destroying transport [%s] =', _self.endpoint.label, _self.tName);\n\t\t\t\t_self.disabled = true;\n\t\t\t\t_self.socket = null;\n\n\t\t\t\tif(_self.stopRecv){\n\t\t\t\t\t// _self.logger.enabled && _self.logger.log('[%s] Destroying transport [%s] - stopRecv found =', _self.endpoint.label, _self.tName);\n\t\t\t\t\t_self.stopRecv(_self.recvHandler);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t_self.as = function (tName) {\n\t\t\t\t// delete _self.endpoint.transports[_self.tName];\n\t\t\t\tvar prevName = _self.tName;\n\t\t\t\t_self.tName = tName;\n\t\t\t\t_self.nameClock++;\n\t\t\t\t_self.logger.enabled && _self.logger.log('[%s] Sending namechange of transport [%s][%s] to [%s] at clock =', _self.endpoint.label, prevName, tName, _self.id, _self.nameClock);\n\t\t\t\t_self.send({\n\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\ttName: _self.tName,\n\t\t\t\t\t\tclock: _self.nameClock\n\t\t\t\t\t},\n\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t});\n\t\t\t\t// // _self.endpoint.transports[tName] = _self;\n\t\t\t\t// if(!_self.initialised) {\n\t\t\t\t// \t_self.initialised = true;\n\t\t\t\t// \tres();\n\t\t\t\t// }\n\t\t\t\treturn _self;\n\t\t\t};\n\n\t\t\t// Triggers an '.as()' function on the remote end of the socket.\n\t\t\t_self.asRemote = function(){\n\t\t\t\t_self.logger.enabled && _self.logger.log('Requesting namechange from remote, at clock =', _self.nameClock);\n\t\t\t\t_self.send({\n\t\t\t\t\trpc_tName_change: {\n\t\t\t\t\t\trequest:true\n\t\t\t\t\t},\n\t\t\t\t\trpc_dir: _self.endpoint.dir\n\t\t\t\t});\n\n\t\t\t\treturn _self;\n\t\t\t};\n\t\t});\n\n\t\t_self.endpoint.transports[_self.id] = _self;\n\t\t_self.logger.enabled && _self.logger.log('Added transport [%s][%s] for endpoint [%s][%s]', type, _self.id, endpoint.label, endpoint.dir);\n\t\treturn _self;\n\t};\n\n\t/* ----------------------------------------------------------- */\n\n\n\tmodule.exports = rpcTransport;\n\n})();\n","(function () {\n\n\tvar transportTypes = {};\n\n\ttransportTypes['socketio'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.send(JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['websocket'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => {\n\t\t\t\treturn new Promise((res, rej) => {\n\t\t\t\t\tsocket.send(\n\t\t\t\t\t\tJSON.stringify(data),\n\t\t\t\t\t\t(e) => e ? rej(e) : res()\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['processLocal'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.emit('message', JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['nodeEELocal'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.emit('message', JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['processRemote'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => {\n\t\t\t\treturn new Promise((res, rej) => {\n\t\t\t\t\tvar s = socket.send(\n\t\t\t\t\t\tJSON.stringify(data),\n\t\t\t\t\t\t(e) => e instanceof Error ? rej(e) : (s === true ? res(s) : rej(s))\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\ttransportTypes['nodeEERemote'] = function (type, socket) {\n\t\treturn {\n\t\t\tsend: (data) => socket.send('message', JSON.stringify(data)),\n\t\t\tonRecv: (fn) => socket.on('message', (data) => fn(JSON.parse(data))),\n\t\t\tstopRecv: (fn) => socket.removeListener('message', fn)\n\t\t}\n\t};\n\n\tmodule.exports = transportTypes;\n\n})();\n","module.exports = function(debug){\n\n\tvar logger = function (suffix) {\n\t\tthis.enabled = false;\n\t\tthis.prefix = suffix || '';\n\n\t\tif(typeof debug == 'function'){\n\t\t\tthis.log = debug(`logs:` + this.prefix);\n\t\t\tthis.warn = debug(`warnings:` + this.prefix);\n\t\t\tthis.error = debug(`errors:` + this.prefix);\n\t\t\tthis.enabled = true;\n\t\t}\n\t\telse{\n\t\t\tthis.log = ()=>{};\n\t\t\tthis.warn = ()=>{};\n\t\t\tthis.error = ()=>{};\n\t\t\tthis.enabled = false;\n\t\t}\n\t};\n\n\tlogger.prototype.child = function (suffix) {\n\t\treturn new logger(this.prefix + ':' + suffix);\n\t};\n\n\treturn logger;\n};\n","module.exports = function (debug) {\n\n\tconst Namespace = require('./components/namespace.js');\n\tconst rpcEndpoint = require('./components/rpcEndpoint.js');\n\tconst debugr = require('debug-pest')(debug);\n\tvar appLogger = new debugr('octopus');\n\n\t/* ----------------------------------------------------------- */\n\n\tvar rpcs = {};\n\n\tvar rpc = function (name, options) {\n\t\toptions = options || {};\n\n\n\t\tif (options.create === true) {\n\t\t\tthis.name = name;\n\t\t\tthis.commands = {};\n\t\t\tthis.logger = appLogger.child(this.name);\n\n\t\t\tthis.incoming = new rpcEndpoint(name, 'i', { logger: this.logger });\n\t\t\tthis.outgoing = new rpcEndpoint(name, 'o', { logger: this.logger });\n\n\t\t\tthis.logger.enabled && this.logger.log('Created new Octopus RPC as ', this.name);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!rpcs[name]) {\n\t\t\toptions.create = true;\n\t\t\trpcs[name] = new rpc(name, options);\n\t\t}\n\n\n\t\treturn rpcs[name];\n\n\t};\n\trpc.prototype.displayTransports = function () {\n\t\t// console.log('\\n\\n\\n------ Transports for [%s] are:\\n', this.name);\n\t\t// console.log('incoming:\\n');\n\t\t// this.incoming.displayTransports();\n\t\t// console.log('\\n\\noutgoing:\\n');\n\t\t// this.outgoing.displayTransports();\n\t\t// console.log('\\n--------------------------\\n\\n');\n\n\t\tvar logString = `\n\n-------------------- TRANSPORTS for [${this.name}] are : ---------------------------\n\nIncoming (provides):\n\n`;\n\n\t\tlogString += this.incoming.displayString();\n\t\tlogString += `\\n\\n-------------\\nOutgoing (calls):\\n\\n`;\n\t\tlogString += this.outgoing.displayString();\n\t\tlogString += '\\n\\n------------------------------------------------------------------------------------\\n\\n';\n\n\t\tconsole.log(logString);\n\t};\n\n\trpc.prototype.over = function (socket, type) {\n\t\tvar tasks = [];\n\t\ttasks.push(\n\t\t\tthis.incoming.over(socket, type)\n\t\t\t.as(this.name)\n\t\t\t.initPromise\n\t\t);\n\t\ttasks.push(\n\t\t\tthis.outgoing.over(socket, type)\n\t\t\t.asRemote()\n\t\t\t.initPromise\n\t\t);\n\t\treturn Promise.all(tasks);\n\t};\n\trpc.prototype.remove = function (socket) {\n\t\tthis.incoming.remove(socket);\n\t\tthis.outgoing.remove(socket);\n\t};\n\n\trpc.prototype.pluginTransports = function (tObj) {\n\t\tthis.incoming.pluginTransports(tObj);\n\t\tthis.outgoing.pluginTransports(tObj);\n\t};\n\trpc.prototype.command = function (name) {\n\t\tvar _self = this;\n\t\tif (!_self.commands[name]) {\n\t\t\tvar iC = _self.incoming.command(name);\n\t\t\tvar oC = _self.outgoing.command(name);\n\t\t\t_self.MESSAGETYPES = iC.MESSAGETYPES || oC.MESSAGETYPES;\n\n\t\t\t_self.commands[name] = {\n\t\t\t\tprovide: function (fn) {\n\t\t\t\t\tiC.provide(fn);\n\t\t\t\t\treturn _self.commands[name];\n\t\t\t\t},\n\t\t\t\tunProvide: function (fn) {\n\t\t\t\t\tiC.unProvide(fn);\n\t\t\t\t\treturn _self.commands[name];\n\t\t\t\t},\n\t\t\t\tonProvide: function (fn) {\n\t\t\t\t\tiC.onProvide(fn);\n\t\t\t\t\treturn _self.commands[name];\n\t\t\t\t},\n\t\t\t\tcall: function (filter, data) {\n\t\t\t\t\t// _self.displayTransports();\n\t\t\t\t\treturn oC.call(filter, data);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn this.commands[name];\n\t};\n\trpc.prototype.renameTo = function (newName) {\n\t\tthis.incoming.rename(this.name)\n\t\t\t.as(newName);\n\t\tthis.name = newName;\n\t\t// this.outgoing.label = newName;\n\t\treturn this;\n\t};\n\n\n\t/* ----------------  Result parsing & Resolving to Promise resolve/reject -----------*/\n\n\trpc.prototype.parseByStatus = function (res) {\n\t\tvar valids = [],\n\t\t\tinvalids = [],\n\t\t\tcheck;\n\t\tfor (var i = 0; i < res.length; i++) {\n\t\t\tcheck = res[i];\n\t\t\tif (check.sent === true && check.status === true)\n\t\t\t\tvalids.push(check);\n\t\t\telse\n\t\t\t\tinvalids.push(check);\n\t\t}\n\t\treturn {\n\t\t\tvalids: valids,\n\t\t\tinvalids: invalids\n\t\t};\n\t};\n\n\trpc.prototype.resolve = function (p) {\n\t\tif (p.sent === true && p.status === true)\n\t\t\treturn Promise.resolve(p.response);\n\t\telse\n\t\t\treturn Promise.reject(p.response);\n\t};\n\trpc.prototype.resolveAll = function (p) {\n\n\t\tfor (var i = 0; i < p.length; i++) {\n\t\t\tif (p[i].sent === false || p[i].status === false)\n\t\t\t\treturn Promise.reject(p);\n\t\t}\n\n\t\treturn Promise.resolve(p);\n\t};\n\trpc.prototype.resolveAtLeastOne = function (p) {\n\n\t\tfor (var i = 0; i < p.length; i++) {\n\t\t\tif (p[i].sent === true && p[i].status === true)\n\t\t\t\treturn Promise.resolve(p);\n\t\t}\n\n\t\treturn Promise.reject(p);\n\t};\n\n\n\n\n\treturn rpc;\n\n};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL25hbWVzcGFjZS5qcyIsImNvbXBvbmVudHMvcnBjQ29tbWFuZC5qcyIsImNvbXBvbmVudHMvcnBjRW5kcG9pbnQuanMiLCJjb21wb25lbnRzL3JwY1RyYW5zcG9ydC5qcyIsImNvbXBvbmVudHMvc3RvY2tUcmFuc3BvcnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnLXBlc3QvaW5kZXguanMiLCJvY3RvcHVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiKGZ1bmN0aW9uICgpIHtcblxuXHQvKiAtLS0tLS1cblx0XG5cdFx0Q29kZSBiZWxvdyBpcyBhZGFwdGVkIGZyb20gdGhlIGRlYnVnIGxpYnJhcnksIGR1bHkgbGljZW5zZWQgYXMgYmVsb3cuXG5cblx0XHQoVGhlIE1JVCBMaWNlbnNlKVxuXG5cdFx0Q29weXJpZ2h0IChjKSAyMDE0IFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XG5cblx0XHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmVcblx0XHRhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG5cdFx0aW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcblx0XHRhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuXHRcdHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cdFx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuXHRcdHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRcdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UXG5cdFx0TElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5cdFx0SU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuXHRcdFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuXHRcdFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cdC0tLS0tLSAqL1xuXG5cdHZhciBOYW1lc3BhY2UgPSBmdW5jdGlvbiAobmFtZXNwYWNlcykge1xuXG5cdFx0dGhpcy5uYW1lcyA9IFtdO1xuXHRcdHRoaXMuc2tpcHMgPSBbXTtcblxuXHRcdHZhciBpO1xuXHRcdHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0dmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0dGhpcy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0TmFtZXNwYWNlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5za2lwc1tpXS50ZXN0KHZhbHVlKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLm5hbWVzW2ldLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXG5cdG1vZHVsZS5leHBvcnRzID0gTmFtZXNwYWNlO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBOYW1lc3BhY2UgPSByZXF1aXJlKCcuL25hbWVzcGFjZS5qcycpO1xuXG5cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cblx0Y29uc3QgTUVTU0FHRVRZUEVTID0ge1xuXHRcdHJlcXVlc3Q6ICdSUScsXG5cdFx0cmVzcG9uc2VBY2NlcHQ6ICdSQScsXG5cdFx0cmVzcG9uc2VGYWlsOiAnUkYnLFxuXHRcdHJlc3BvbnNlQWNjZXB0RXJyb3I6ICdSQUUnLFxuXHRcdHJlc3BvbnNlRmFpbEVycm9yOiAnUkZFJ1xuXHR9O1xuXG5cblx0dmFyIHJwY0NvbW1hbmQgPSBmdW5jdGlvbiAobmFtZSwgZW5kcG9pbnQsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHQvLyBjb25zb2xlLmxvZygnQ3JlYXRpbmcgcnBjIGNvbW1hbmQgWyVzXSBmb3IgZW5kcG9pbnQgWyVzXVslc10nLG5hbWUsIGVuZHBvaW50LmxhYmVsLCBlbmRwb2ludC5kaXIpO1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuXHRcdHRoaXMucmVxdWVzdEhhbmRsZXJzID0gW107XG5cdFx0dGhpcy5yZXNwb25zZUhhbmRsZXJzID0ge307XG5cdFx0dGhpcy5vblByb3ZpZGVGbiA9IG51bGw7XG5cdFx0dGhpcy5lbmRwb2ludC5jb21tYW5kc1tuYW1lXSA9IHRoaXM7XG5cblx0XHR0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyLmNoaWxkKCdDTUQ6JyArIHRoaXMubmFtZSk7XG5cdFx0dGhpcy5zZW5kTG9nZ2VyID0gdGhpcy5sb2dnZXIuY2hpbGQoJ3NlbmQnKTtcblx0XHR0aGlzLnJlY3ZMb2dnZXIgPSB0aGlzLmxvZ2dlci5jaGlsZCgncmVjdicpO1xuXHRcdHRoaXMubG9nZ2VyLmVuYWJsZWQgJiYgdGhpcy5sb2dnZXIubG9nKCdDcmVhdGVkIG5ldyBjb21tYW5kIGFzICcsIG5hbWUpO1xuXG5cdFx0dGhpcy5NRVNTQUdFVFlQRVMgPSBNRVNTQUdFVFlQRVM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHRycGNDb21tYW5kLnByb3RvdHlwZS5hdXRvSUQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoOCkgKyAnLScgKyBEYXRlLm5vdygpO1xuXHR9O1xuXG5cdHJwY0NvbW1hbmQucHJvdG90eXBlLnNlbmRUb0lEID0gZnVuY3Rpb24gKHRpZCwgbXNnLCBtb2RlLCBwVHJhbnNOYW1lKSB7XG5cdFx0dmFyIF9zZWxmID0gdGhpcztcblxuXHRcdG1zZy5tc2dJRCA9IF9zZWxmLmF1dG9JRCgpO1xuXHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnXFxuXFxuW3NlbmRUb0lEXSBjYWxsZWQgd2l0aCB0aWRbJXNdLCBtc2dJRFslc10sIG1vZGVbJXNdLCBwVHJhbnNOYW1lWyVzXSBcXG4nLCB0aWQsIG1zZy5tc2dJRCwgbW9kZSwgcFRyYW5zTmFtZSk7XG5cblx0XHQvKlxuXHRcdFx0Tk9URSAtIEFkZGluZyBhIGNoZWNrIGFzIGEgaG90Zml4IHRvIGF2b2luZCBjcmFzaGluZyBvbiB0TmFtZSBlcnJvcnMuXG5cblx0XHRcdFNvdXJjZSBvZiBlcnJvcnMgLSBzZW5kVG9JRCBpcyBjYWxsZWQgZnJvbSBjYWxsKCkgYXMgd2VsbCBhcyByZWN1cnNpdmVseSwgd2hlbiByZXNwb25kaW5nIHRvIG1lc3NhZ2VzLlxuXG5cdFx0XHRUaGUgc291cmNlIG9mIHROYW1lIGVycm9ycyBtYXkgYmUgdGhlIGFzeW5jIG5hdHVyZS4gU2luY2UgdGhpcyBpcyBhc3luYywgdGhlcmUncyBhIGdhcCBpbiBiZXR3ZWVuIGNhbGwgJiBleGVjdXRpb25cblx0XHRcdGJldHdlZW4gd2hpY2ggYSBcInJlbW92ZSgpXCIgZnVuY3Rpb24gY2FsbCBtaWdodCBkZWxldGUgdGhlIHRyYW5zcG9ydCwgcmFpc2luZyBzdWNoIGlzc3Vlcy5cblxuXHRcdFx0Q2FzZSAjMSAtIERlbGV0ZWQgdHJhbnNwb3J0IGFmdGVyIGEgY2FsbCBmcm9tIC5jYWxsKCksIGJ1dCBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBvZiBzZW5kVG9JRCwgY2F1c2luZyB0TmFtZSBlcnJvcnMuXG5cdFx0XHRDYXNlICMyIC0gQWx0ZXJuYXRlbHksIERlbGV0ZWQgdGhlIHRyYW5zcG9ydCBhZnRlciBhIG1lc3NhZ2Ugd2FzIHJlY2lldmVkLCBidXQgYmVmb3JlIGEgcmVzcG9uc2UgY291bGQgYmUgc2VudC5cblxuXHRcdFx0Tk9URSAtIEVER0UgQ0FTRSBUTyBTT0xWRSA6XG5cdFx0XHRXaGF0IGhhcHBlbnMgaWYgaW4gZWl0aGVyIGNhc2UsIHRoZSByZXNwb25zZSBpcyBjcml0aWNhbCBmb3IgcHJvcGVyIGZ1bmN0aW9uIC8gYXZvaWRpbmcgZHVwbGljYXRpb24gb2YgY2FsbHMgKHNlZSBiZWxvdyksXG5cdFx0XHRhbmQgY291bGQgYmUgc2VudCBiZWNhdXNlIHRoZSByZWNpZXZlciBzdGlsbCBleGlzdHMgKGllIHNhbWUgdE5hbWUpLCBidXQgb3ZlciBhIGRpZmZlcmVudCB0cmFuc3BvcnQgKGllIGRpZmZlcmVudCB0SUQpLlxuXG5cdFx0XHRIb3cgZHVwbGljYXRpb24gb2YgY2FsbHMgLVxuXHRcdFx0XHRTZW5kZXIgc2VuZHMgUlBDXG5cdFx0XHRcdFJlY2lldmVyIGdldHMgUlBDICYgZXhlY3V0ZXMgcHJvdmlkZXJcblx0XHRcdFx0U2VuZGVyIGRpc2Nvbm5lY3RzICYgcmVjb25uZWN0cyB3aXRoIGEgbmV3IGNvbm5lY3Rpb25cblx0XHRcdFx0UmVjaWV2ZXIgcmVtb3ZlcyBwcmV2aW91cyBzb2NrZXQgJiByZS1hZGRzIG5ldyBzb2NrZXQgKGllIHNhbWUgdE5hbWUsIG9uY2UgaW5pdGlhbCBoYW5kc2hha2UgaXMgZG9uZSwgYnV0IGRpZmZlcmVudCB0SUQpLlxuXHRcdFx0XHRSZWNpZXZlciBSUEMgY2FsbCByZXNwb25zZSBmYWlscyAvIGlnbm9yZWQgYmVjYXVzZSBvbGQgdElEIGRvZXNuJ3QgZXhpc3QgYW55bW9yZS5cblx0XHRcdFx0U2VuZGVyIHRpbWVzIG91dCAob3IgY29uc2lkZXJzIGZhaWx1cmUgZHVlIHRvIGRpc2Nvbm5lY3Rpb24gLyByZW1haW5zIGhhbmdpbmcgYXMgYSBtZW1vcnkgbGVhayksIGV2ZW4gdGhvdWdoIFJQQyBwcm92aWRlciBoYXMgZXhlY3V0ZWQgb24gcmVjaWV2ZXJcblx0XHRcdFx0QXBwbGljYXRpb24gdHJpZXMgYWdhaW4gYXNzdW1pbmcgYmFkIFJQQyBjYWxsLlxuXG5cdFx0XHRQb3NzaWJsZSBzb2x1dGlvbiAtXG5cdFx0XHRcdGlmIHRJRCBtaXNtYXRjaCBpcyBmb3VuZCxcblx0XHRcdFx0XHRhIHNlYXJjaCBvZiBvdGhlciB0cmFuc3BvcnRzIHdpdGggdGhlIHNhbWUgdE5hbWUgaXMgZG9uZSxcblx0XHRcdFx0XHQgXHRpZiBmb3VuZCwgc2VuZCBhcyB1c3VhbCBhbmQgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0aWYgbm90IGZvdW5kLFxuXHRcdFx0XHRcdFx0XHRjYWxsIGlzIGhvb2tlZCBhbmQgd2FpdHMgdGlsbCBhbm90aGVyIHRyYW5zcG9ydCB3aXRoIHRoZSBzYW1lIG5hbWUgY29ubmVjdHMgYmVmb3JlIHRpbWVvdXRcblx0XHRcdFx0XHRcdFx0aWYgY29ubmVjdHMsXG5cdFx0XHRcdFx0XHRcdFx0c2VuZCBhcyB1c3VhbCAmIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0aWYgbm90LFxuXHRcdFx0XHRcdFx0XHRcdGZhaWwgd2l0aCBhIHRpbWVvdXRcblx0XHQqL1xuXG5cdFx0aWYgKHRpZCA9PT0gJycgfHwgIV9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbdGlkXSkge1xuXHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdcXG5cXG5bc2VuZFRvSURdIHRyYW5zcG9ydCB0byB0aWRbJXNdIGRvZXMgbm90IGV4aXN0LiBUYWtpbmcgY29ycmVjdGl2ZSBhY3Rpb24uLi4gXFxuJywgdGlkKTtcblxuXG5cdFx0XHR2YXIgdHJhbnMgPSBfc2VsZi5lbmRwb2ludC5maW5kVHJhbnNwb3J0QnlOYW1lKHBUcmFuc05hbWUpO1xuXG5cdFx0XHQvLyBJZiBmb3VuZCwgY29udGludWUgd2l0aCBkaXNjb3ZlcmVkIHRyYW5zcG9ydFxuXHRcdFx0aWYgKHRyYW5zKSB7XG5cdFx0XHRcdHRpZCA9IHRyYW5zLmlkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbHNlIHdhaXQgZm9yIGEgbmV3IHRyYW5zcG9ydCB0byBjb25uZWN0LCBvciByZWplY3Qgb24gdGltZW91dFxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG5cdFx0XHRcdFx0Ly8gV2FpdCBmb3IgbmV3IHRyYW5zcG9ydCB3aXRoIGdpdmVuIG5hbWUgdG8gc2V0dXBcblx0XHRcdFx0XHQudGhlbigoKSA9PiBfc2VsZi5lbmRwb2ludC5hZGRUcmFuc3BvcnROYW1lQ2hhbmdlSG9vayhwVHJhbnNOYW1lKSlcblxuXHRcdFx0XHRcdC8vIE9uY2UgaG9vayBmaXJlcywgY2FsbCB0aGlzIHJlY3Vyc2l2ZWx5IGFuZCB0cnkgdG8gcmVzZW5kXG5cdFx0XHRcdFx0LnRoZW4oKHQpID0+IHRoaXMuc2VuZFRvSUQodC5pZCwgbXNnLCBtb2RlLCBwVHJhbnNOYW1lKSlcblxuXHRcdFx0XHRcdC8vIFJlamVjdCBpZiBpdCBmYWlscyAod29yc3QgY2FzZSBzaXR1YXRpb24pXG5cdFx0XHRcdFx0LmNhdGNoKCgpID0+IHtcblx0XHRcdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLndhcm4oJ1tFUlJPUl0gdHJhbnNwb3J0IHROYW1lWyVzXSB3YXMgbm90IGZvdW5kIGFzIHRpZFslc10uIE1pZ2h0IGxlYWQgdG8gZHVwbGljYXRlZCBwcm92aWRlciBleGVjdXRpb25zLCBpZiByZS1jb25uZWN0aW9ucyBjYXVzZWQgaXQuJywgdE5hbWUsIHRpZCk7XG5cblx0XHRcdFx0XHRcdGlmICghbW9kZSB8fCBtb2RlICE9ICdyZXNwb25kJykge1xuXHRcdFx0XHRcdFx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci53YXJuKCdDYW5ub3QgY2FsbCAtIG1pc3NpbmcgdHJhbnNwb3J0Jyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuXHRcdFx0XHRcdFx0XHRcdHNlbnQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdHN0YXR1czogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNwb3J0OiBwVHJhbnNOYW1lLFxuXHRcdFx0XHRcdFx0XHRcdGNvbW1hbmQ6IF9zZWxmLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2U6ICd0cmFuc3BvcnQgcmVtb3ZlZCBvciBjaGFuZ2VkJ1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLndhcm4oJ0Nhbm5vdCByZXNwb25kIC0gbWlzc2luZyB0cmFuc3BvcnQnKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KCd0cmFuc3BvcnQgbWlzc2luZycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE5PVEUgLSBJbiBjYXNlIHRoZSB0TmFtZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgY2FsbFxuXHRcdHZhciB0TmFtZSA9IF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbdGlkXS50TmFtZTtcblxuXHRcdG1zZy5zb3VyY2UgPSBfc2VsZi5lbmRwb2ludC5sYWJlbDtcblx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci5sb2coJ1NlbmRpbmcgb24gdHJhbnNwb3J0IFslc11bJXNdLCBtb2RlID0gJXMsICBtc2cgPScsIHRpZCwgdE5hbWUsIG1vZGUsIG1zZyk7XG5cblxuXHRcdGlmICghbW9kZSB8fCBtb2RlICE9ICdyZXNwb25kJykge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cblx0XHRcdFx0dmFyIHNlbnQgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBoYW5kbGVyIGZ1bmN0aW9uXG5cdFx0XHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHJlc3BEYXRhLCBtc2dUeXBlKSB7XG5cdFx0XHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdcXG5cXG5SZXNwb25zZSBoYW5kbGVyIGNhbGxlZCB3aXRoIHJlc3BEYXRhICYgbXNnVHlwZXMgYXMgXFxuJywgcmVzcERhdGEsIG1zZ1R5cGUpO1xuXG5cdFx0XHRcdFx0ZGVsZXRlIF9zZWxmLnJlc3BvbnNlSGFuZGxlcnNbdE5hbWVdW21zZy5tc2dJRF07XG5cblxuXHRcdFx0XHRcdHN3aXRjaCAobXNnVHlwZSkge1xuXG5cdFx0XHRcdFx0Y2FzZSBNRVNTQUdFVFlQRVMucmVzcG9uc2VBY2NlcHQ6XG5cdFx0XHRcdFx0XHRyZXMoe1xuXHRcdFx0XHRcdFx0XHRzZW50OiBzZW50LFxuXHRcdFx0XHRcdFx0XHRzdGF0dXM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHRyYW5zcG9ydDogdE5hbWUsXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmQ6IF9zZWxmLm5hbWUsXG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlOiByZXNwRGF0YVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgTUVTU0FHRVRZUEVTLnJlc3BvbnNlRmFpbDpcblx0XHRcdFx0XHRcdHJlcyh7XG5cdFx0XHRcdFx0XHRcdHNlbnQ6IHNlbnQsXG5cdFx0XHRcdFx0XHRcdHN0YXR1czogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdHRyYW5zcG9ydDogdE5hbWUsXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmQ6IF9zZWxmLm5hbWUsXG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlOiByZXNwRGF0YVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fTtcblxuXG5cdFx0XHRcdGlmICghX3NlbGYucmVzcG9uc2VIYW5kbGVyc1t0TmFtZV0pXG5cdFx0XHRcdFx0X3NlbGYucmVzcG9uc2VIYW5kbGVyc1t0TmFtZV0gPSB7fTtcblxuXHRcdFx0XHRfc2VsZi5zZW5kTG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYuc2VuZExvZ2dlci5sb2coJ1xcblxcbkFkZGluZyByZXNwb25zZSBoYW5kbGVyIGF0IFslc11bJXNdIFxcbicsIHROYW1lLCBtc2cubXNnSUQpO1xuXHRcdFx0XHRfc2VsZi5yZXNwb25zZUhhbmRsZXJzW3ROYW1lXVttc2cubXNnSURdID0gaGFuZGxlcjtcblxuXG5cdFx0XHRcdHZhciBjb250YWluZXIgPSB7XG5cdFx0XHRcdFx0cnBjX21zZzoge30sXG5cdFx0XHRcdFx0cnBjX2RpcjogX3NlbGYuZW5kcG9pbnQuZGlyXG5cdFx0XHRcdH07XG5cdFx0XHRcdGNvbnRhaW5lci5ycGNfbXNnW19zZWxmLm5hbWVdID0gbXNnO1xuXG5cdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnXFxuXFxuXFxuU2VuZGluZyAlcyB0byBbJXNdIGFzIFxcbicsIG1vZGUgPT0gJ3Jlc3BvbmQnID8gJ3Jlc3BvbnNlJyA6ICdyZXF1ZXN0JywgdE5hbWUsIGNvbnRhaW5lcik7XG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZShfc2VsZi5lbmRwb2ludC50cmFuc3BvcnRzW3RpZF0uc2VuZChjb250YWluZXIpKVxuXHRcdFx0XHRcdC50aGVuKChzKSA9PiBzZW50ID0gdHJ1ZSlcblx0XHRcdFx0XHQuY2F0Y2goKGUpID0+IHtcblx0XHRcdFx0XHRcdHNlbnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGhhbmRsZXIoZSwgTUVTU0FHRVRZUEVTLnJlc3BvbnNlRmFpbCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBjb250YWluZXIgPSB7XG5cdFx0XHRcdHJwY19tc2c6IHt9LFxuXHRcdFx0XHRycGNfZGlyOiBfc2VsZi5lbmRwb2ludC5kaXJcblx0XHRcdH07XG5cdFx0XHRjb250YWluZXIucnBjX21zZ1tfc2VsZi5uYW1lXSA9IG1zZztcblxuXHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdcXG5cXG5cXG5TZW5kaW5nICVzIHRvIFslc10gYXMgXFxuJywgbW9kZSA9PSAncmVzcG9uZCcgPyAncmVzcG9uc2UnIDogJ3JlcXVlc3QnLCB0TmFtZSwgY29udGFpbmVyKTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1t0aWRdLnNlbmQoY29udGFpbmVyKSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdFx0RGF0YSBjYW4gYmUgYSB2YWx1ZSBvciBhIGZ1bmN0aW9uLlxuXHRcdElmIGl0cyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGV2YWx1YXRlZCBmb3IgZXZlcnkgbmV3IHRyYW5zcG9ydFxuXG5cdFx0YW5kIHBhc3NlZCBwYXJhbXMgYXM6XG5cdFx0XHQxLiB0aGUgdHJhbnNwb3J0IHROYW1lLCBpbmRleCAtIGlmIGZvdW5kLlxuXHRcdFx0Mi4gbnVsbCwgbnVsbCAtIGlmIG5vIHRyYW5zcG9ydHMgYXJlIGZvdW5kLCBhbmQgaXQgZ29lcyB0byB3YWl0aW5nXG5cblx0XHQvL1RPRE8gLSBpbXByb3ZlIGNvbnNpc3RlbmN5IGluIHBhcmFtcyBwYXNzZWQgdG8gZGF0YSBmdW5jdGlvbi5cblxuXHQqL1xuXHRycGNDb21tYW5kLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgZGF0YSwgbW9kZSkge1xuXHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHROYW1lO1xuXHRcdHZhciB0YXNrcyA9IFtdO1xuXHRcdHZhciBldmFsdWF0ZSA9IGZhbHNlO1xuXG5cblx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGV2YWx1YXRlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBTZW5kIHRvIGFsbCB0cmFuc3BvcnRzIHRoYXQgbWF0Y2ggdGhlIG5hbWVzcGFjZVxuXHRcdHZhciB0YXNrcyA9IF9zZWxmLmVuZHBvaW50LmZpbmRUcmFuc3BvcnRzQnlOYW1lc3BhY2UobmFtZXNwYWNlLCB7IGluaXRpYWxpc2VkOiB0cnVlIH0pXG5cdFx0XHQubWFwKCh0LCBpKSA9PiB7XG5cdFx0XHRcdHZhciBtc2cgPSB7XG5cdFx0XHRcdFx0bXNnSUQ6IF9zZWxmLmF1dG9JRCgpLFxuXHRcdFx0XHRcdG1zZ1R5cGU6IE1FU1NBR0VUWVBFUy5yZXF1ZXN0LFxuXHRcdFx0XHRcdHJlcURhdGE6IGV2YWx1YXRlID09PSB0cnVlID8gZGF0YSh0LnROYW1lLCBpKSA6IGRhdGEsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdUcmFuc3BvcnQgWyVzXSBpcyB2YWxpZC4gQXR0ZW1wdGluZyB0byBzZW5kJywgdC5pZCk7XG5cblx0XHRcdFx0cmV0dXJuIF9zZWxmLnNlbmRUb0lEKHQuaWQsIG1zZywgbW9kZSwgdC50TmFtZSk7XG5cdFx0XHR9KTtcblxuXG5cdFx0Ly8gSWYgdHJhbnNwb3J0cyB3ZXJlIG5vdCBmb3VuZCxcblx0XHQvLyBob29rICYgd2FpdCBmb3IgdGhlIGZpcnN0IHZhbGlkIHRyYW5zcG9ydCB0aGF0IGNvbm5lY3RzXG5cdFx0aWYgKHRhc2tzLmxlbmd0aCA9PSAwKXtcblxuXHRcdFx0dmFyIG1zZyA9IHtcblx0XHRcdFx0bXNnSUQ6IF9zZWxmLmF1dG9JRCgpLFxuXHRcdFx0XHRtc2dUeXBlOiBNRVNTQUdFVFlQRVMucmVxdWVzdCxcblx0XHRcdFx0cmVxRGF0YTogZXZhbHVhdGUgPT09IHRydWUgPyBkYXRhKG51bGwsIG51bGwpIDogZGF0YSxcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnTm8gdHJhbnNwb3J0cyBmb3VuZCBmb3IgWyVzXS4gV2FpdGluZycsIG5hbWVzcGFjZSk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbChbX3NlbGYuc2VuZFRvSUQoJycsIG1zZywgbW9kZSwgbmFtZXNwYWNlKV0pO1xuXG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCB3YWl0IHRpbGwgYWxsIG1lc3NhZ2VzIGhhdmUgYmVlbiBzZW50ICYgcmVzb2x2ZS5cblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwodGFza3MpO1xuXG5cblx0fTtcblxuXHQvLyBycGNDb21tYW5kLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG5hbWVzcGFjZVN0cmluZywgZGF0YSkge1xuXHQvLyBcdHZhciBfc2VsZiA9IHRoaXM7XG5cdC8vXG5cdC8vIFx0dmFyIG1zZyA9IHtcblx0Ly8gXHRcdG1zZ0lEOiBfc2VsZi5hdXRvSUQoKSxcblx0Ly8gXHRcdG1zZ1R5cGU6IE1FU1NBR0VUWVBFUy5yZXF1ZXN0LFxuXHQvLyBcdFx0cmVxRGF0YTogZGF0YSxcblx0Ly8gXHR9O1xuXHQvL1xuXHQvL1xuXHQvLyBcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnUmVxdWVzdGluZyBSUEMgd2l0aCBtc2cgPSAnLCBtc2cpO1xuXHQvLyBcdHJldHVybiBfc2VsZi5zZW5kKG5hbWVzcGFjZVN0cmluZywgbXNnKTtcblx0Ly9cblx0Ly8gfTtcblxuXG5cdHJwY0NvbW1hbmQucHJvdG90eXBlLnJlY2lldmUgPSBmdW5jdGlvbiAobXNnLCB0cmFuc3BvcnQpIHtcblx0XHR2YXIgX3NlbGYgPSB0aGlzO1xuXHRcdHZhciB0TmFtZSA9IHRyYW5zcG9ydC50TmFtZSxcblx0XHRcdHRpZCA9IHRyYW5zcG9ydC5pZDtcblxuXHRcdF9zZWxmLnJlY3ZMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5yZWN2TG9nZ2VyLmxvZygnXFxuXFxuXFxuQ29tbWFuZCBbJXNdIERhdGEgcmVjdmQgb24gWyVzXVslc10gYXMgXFxuJywgX3NlbGYubmFtZSwgX3NlbGYuZW5kcG9pbnQubGFiZWwsIF9zZWxmLmVuZHBvaW50LmRpciwgdE5hbWUsIG1zZyk7XG5cblx0XHRzd2l0Y2ggKG1zZy5tc2dUeXBlKSB7XG5cdFx0Y2FzZSBNRVNTQUdFVFlQRVMucmVzcG9uc2VBY2NlcHQ6XG5cdFx0Y2FzZSBNRVNTQUdFVFlQRVMucmVzcG9uc2VGYWlsOlxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1xcblxcblxcblJlc3BvbnNlIHJlY3ZkIG9uIFslc10gZnJvbSBbJXNdIGFzXFxuICcsdE5hbWUsIG1zZy5ydE5hbWUsIG1zZyk7XG5cdFx0XHRpZiAoX3NlbGYucmVzcG9uc2VIYW5kbGVyc1t0TmFtZV0gJiYgX3NlbGYucmVzcG9uc2VIYW5kbGVyc1t0TmFtZV1bbXNnLnJlc3BJRF0pIHtcblx0XHRcdFx0X3NlbGYuc2VuZExvZ2dlci5lbmFibGVkICYmIF9zZWxmLnNlbmRMb2dnZXIubG9nKCdoYW5kbGVyIGZvdW5kLiBSZXNwb25kaW5nICEnKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShfc2VsZi5yZXNwb25zZUhhbmRsZXJzW3ROYW1lXVttc2cucmVzcElEXShtc2cucmVzcERhdGEsIG1zZy5tc2dUeXBlKSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9zZWxmLnNlbmRMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5zZW5kTG9nZ2VyLmxvZygnaGFuZGxlciBub3QgZm91bmQnKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignaGFuZGxlciBub3QgZm91bmQnKSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgTUVTU0FHRVRZUEVTLnJlcXVlc3Q6XG5cdFx0XHQvLyBjb25zb2xlIC5sb2coJ1xcblxcbkNvbW1hbmRbJXNdIFJlcXVlc3QgcmVjdmQgb24gWyVzXSBhc1xcbiAnLF9zZWxmLm5hbWUsIHROYW1lLG1zZyk7XG5cblx0XHRcdGlmIChfc2VsZi5yZXF1ZXN0SGFuZGxlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnXFxuWyVzXVJlcXVlc3QgaGFuZGxlcnMgZm91bmRcXG4gJyxfc2VsZi5yZXF1ZXN0SGFuZGxlcnMubGVuZ3RoKTtcblxuXHRcdFx0XHR2YXIgY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0dmFyIHJlcURhdGEgPSBtc2cucmVxRGF0YTtcblxuXHRcdFx0XHRfc2VsZi5yZXF1ZXN0SGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4ge1xuXHRcdFx0XHRcdC8qIEVhY2ggaGFuZGxlciBpcyBjYWxsZWQgd2l0aCAodixwLHMsdCxtc2cpIGFzIGZvbGxvd3Ncblx0XHRcdFx0XHRcdHZcdD0gcmVxRGF0YSBcdC0gZGF0YSBzZW50IGJ5IGNhbGxlcixcblx0XHRcdFx0XHRcdHBcdD0gcHJldlx0XHQtIHJlc3BvbnNlIGdvdCBmcm9tIHRoZSBwcmV2aGFuZGxlcidzIGV4ZWN1dGlvbiBmb3IgdGhpcyBjYWxsLFxuXHRcdFx0XHRcdFx0cyBcdD0gbXNnLnNvdXJjZSBcdC0gbmFtZSBvZiB0aGUgY2FsbGluZyB0cmFuc3BvcnQgKHRoaXMgd2FzIHRoZSBhY3R1YWwgdXNlY2FzZSBmb3IgdE5hbWUgPylcblx0XHRcdFx0XHRcdHRcdD0gdE5hbWUgXHRcdC0gbmFtZSBvZiBjdXJyZW50IHRyYW5zcG9ydCAoVE9ETyAtIGJ1Z2d5LCBwb2ludHMgdG8gbG9jYWwgdHJhbnNwb3J0IG5hbWUpXG5cdFx0XHRcdFx0XHRtc2cgXHQ9IG1zZyBcdFx0LSBmdWxsIHJhdyBtc2cgb2JqXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRjaGFpbiA9IGNoYWluLnRoZW4oKHByZXYpID0+IGgobXNnLnJlcURhdGEsIHByZXYsIG1zZy5zb3VyY2UsIHROYW1lLCBtc2cpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBjaGFpblxuXHRcdFx0XHRcdC50aGVuKChyZXNwRGF0YSkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1xcblJlcXVlc3QgaGFuZGxlcnMgU1VDQ0VTU1xcbiBSZXN1bHRzIGFyZScscmVzcERhdGEpO1xuXG5cdFx0XHRcdFx0XHRtc2cucmVzcElEID0gbXNnLm1zZ0lEO1xuXHRcdFx0XHRcdFx0bXNnLnJ0TmFtZSA9IHROYW1lO1xuXHRcdFx0XHRcdFx0bXNnLm1zZ0lEID0gX3NlbGYuYXV0b0lEKCk7XG5cdFx0XHRcdFx0XHRtc2cubXNnVHlwZSA9IE1FU1NBR0VUWVBFUy5yZXNwb25zZUFjY2VwdDtcblx0XHRcdFx0XHRcdG1zZy5yZXNwRGF0YSA9IHJlc3BEYXRhO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIG1zZy5yZXFEYXRhO1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9zZWxmLnNlbmRUb0lEKHRpZCwgbXNnLCAncmVzcG9uZCcsIHROYW1lKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5jYXRjaCgoZSkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1xcblJlcXVlc3QgaGFuZGxlcnMgRkFJTEVEXFxuIFJlc3VsdHMgYXJlJyxlKTtcblxuXHRcdFx0XHRcdFx0bXNnLnJlc3BJRCA9IG1zZy5tc2dJRDtcblx0XHRcdFx0XHRcdG1zZy5ydE5hbWUgPSB0TmFtZTtcblx0XHRcdFx0XHRcdG1zZy5tc2dJRCA9IF9zZWxmLmF1dG9JRCgpO1xuXHRcdFx0XHRcdFx0bXNnLm1zZ1R5cGUgPSBNRVNTQUdFVFlQRVMucmVzcG9uc2VGYWlsO1xuXHRcdFx0XHRcdFx0bXNnLnJlc3BEYXRhID0gZTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBtc2cucmVxRGF0YTtcblx0XHRcdFx0XHRcdHJldHVybiBfc2VsZi5zZW5kVG9JRCh0aWQsIG1zZywgJ3Jlc3BvbmQnLCB0TmFtZSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQudGhlbigoKSA9PiBfc2VsZi5vblByb3ZpZGVGbiA/IF9zZWxmLm9uUHJvdmlkZUZuKHJlcURhdGEsIG1zZy5yZXNwRGF0YSwgdE5hbWUsIG1zZykgOiBudWxsKVxuXHRcdFx0XHRcdC5jYXRjaCgoZSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignW09jdG9wdXNdIEVycm9yIHdoaWxlIGV4ZWN1dGluZyBbJXNdIHByb3ZpZGVyIGNoYWluIG9uIFslc10gLSAnLCBfc2VsZi5uYW1lLCB0TmFtZSwgZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9zZWxmLnJlY3ZMb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5yZWN2TG9nZ2VyLmVycm9yKCdFUlJPUiAtIE5vIHJlcXVlc3RIYW5kbGVycyBmb3IgY29tbWFuZFslc10gb24gWyVzXVslc10gLSAgdE5hbWUsIG1zZyAtICcsIF9zZWxmLm5hbWUsIF9zZWxmLmVuZHBvaW50LmxhYmVsLCBfc2VsZi5lbmRwb2ludC5kaXIsIHROYW1lLCBtc2cpO1xuXHRcdFx0XHRtc2cucmVzcElEID0gbXNnLm1zZ0lEO1xuXHRcdFx0XHRtc2cucnROYW1lID0gdE5hbWU7XG5cdFx0XHRcdG1zZy5tc2dJRCA9IF9zZWxmLmF1dG9JRCgpO1xuXHRcdFx0XHRtc2cubXNnVHlwZSA9IE1FU1NBR0VUWVBFUy5yZXNwb25zZUZhaWw7XG5cdFx0XHRcdG1zZy5yZXNwRGF0YSA9ICdubyBwcm92aWRlcnMnO1xuXHRcdFx0XHRkZWxldGUgbXNnLnJlcURhdGE7XG5cdFx0XHRcdHJldHVybiBfc2VsZi5zZW5kVG9JRCh0aWQsIG1zZywgJ3Jlc3BvbmQnLCB0TmFtZSk7XG5cblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRycGNDb21tYW5kLnByb3RvdHlwZS5wcm92aWRlID0gZnVuY3Rpb24gKGZuKSB7XG5cdFx0aWYgKHR5cGVvZiBmbiA9PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHR0aGlzLnJlcXVlc3RIYW5kbGVycy5wdXNoKGZuKTtcblx0XHRlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUGFyYW0gcGFzc2VkIHRvIFwicHJvdmlkZVwiIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdFx0fVxuXHR9O1xuXG5cdHJwY0NvbW1hbmQucHJvdG90eXBlLnVuUHJvdmlkZSA9IGZ1bmN0aW9uIChmbikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMucmVxdWVzdEhhbmRsZXJzLmZpbmRJbmRleCgoeCkgPT4geCA9PT0gZm4pO1xuXHRcdGlmIChpbmRleCA+IC0xKVxuXHRcdFx0dGhpcy5yZXF1ZXN0SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKlxuXHRcdEV4ZWN1dGVzIHBhc3NlZCBmbiB3aGVuIHByb3ZpZGUgcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bGx5IHJlY2lldmVkIGJ5IHJlbW90ZS5cblx0XHRcdEFzc3VtaW5nIHRyYW5zcG9ydCBzZW5kKCkgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2Ugb24gc3VjY2Vzc2Z1bGxcblx0XHRcdHRyYW5zZmVyIG9mIHJlc3BvbnNlIG1lc3NhZ2Vcblx0Ki9cblx0cnBjQ29tbWFuZC5wcm90b3R5cGUub25Qcm92aWRlID0gZnVuY3Rpb24gKGZuKSB7XG5cdFx0aWYgKHR5cGVvZiBmbiA9PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHR0aGlzLm9uUHJvdmlkZUZuID0gZm47XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtIHBhc3NlZCB0byBcIm9uUHJvdmlkZUZuXCIgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHR9XG5cdH07XG5cblxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJwY0NvbW1hbmQ7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vbmFtZXNwYWNlLmpzJyk7XG5cdGNvbnN0IHJwY1N0b2NrVHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vc3RvY2tUcmFuc3BvcnRzLmpzJyk7XG5cdGNvbnN0IHJwY1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4vcnBjVHJhbnNwb3J0LmpzJyk7XG5cdGNvbnN0IHJwY0NvbW1hbmQgPSByZXF1aXJlKCcuL3JwY0NvbW1hbmQuanMnKTtcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5cdHZhciBycGNFbmRwb2ludCA9IGZ1bmN0aW9uIChsLCBkaXIsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyLmNoaWxkKGRpciA9PSAnaScgPyAnRVA6aW4nIDogJ0VQOm91dCcpO1xuXG5cblx0XHR0aGlzLnRyYW5zcG9ydHMgPSB7fTtcblx0XHR0aGlzLm5hbWVDaGFuZ2VIb29rcyA9IHt9O1xuXHRcdHRoaXMubGFiZWwgPSBsO1xuXHRcdHRoaXMuZGlyID0gZGlyO1xuXHRcdHRoaXMuY29tbWFuZHMgPSB7fTtcblx0XHR0aGlzLnRyYW5zcG9ydFR5cGVzID0gcnBjU3RvY2tUcmFuc3BvcnRzO1xuXG5cdFx0dGhpcy5sb2dnZXIuZW5hYmxlZCAmJiB0aGlzLmxvZ2dlci5sb2coJ0NyZWF0ZWQgbmV3IGVuZHBvaW50IGFzIFslc11bJXNdJywgbCwgZGlyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5wbHVnaW5UcmFuc3BvcnRzID0gZnVuY3Rpb24gKHRDb2xsKSB7XG5cdFx0dGhpcy50cmFuc3BvcnRUeXBlcyA9IE9iamVjdC5hc3NpZ24odGhpcy50cmFuc3BvcnRUeXBlcywgdENvbGwpO1xuXHR9O1xuXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5vdmVyID0gZnVuY3Rpb24gKHNvY2tldCwgdHlwZSkge1xuXHRcdHJldHVybiBuZXcgcnBjVHJhbnNwb3J0KHR5cGUsIHNvY2tldCwgdGhpcywgeyBsb2dnZXI6IHRoaXMubG9nZ2VyIH0pO1xuXHR9O1xuXHRycGNFbmRwb2ludC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHNvY2tldCkge1xuXHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0Ly8gT2JqZWN0LmtleXMoX3NlbGYudHJhbnNwb3J0cykuZm9yRWFjaCgodGlkKSA9PiB7XG5cdFx0Ly8gXHRpZiAoX3NlbGYudHJhbnNwb3J0c1t0aWRdLnNvY2tldCA9PSBzb2NrZXQpe1xuXHRcdC8vIFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdEZXN0cm95aW5nICYgcmVtb3ZpbmcgdHJhbnNwb3J0IFslc10gdE5hbWUgWyVzXS4gJyx0aWQsX3NlbGYudHJhbnNwb3J0c1t0aWRdLnROYW1lKTtcblx0XHQvLyBcdFx0X3NlbGYudHJhbnNwb3J0c1t0aWRdLmRlc3Ryb3koKTtcblx0XHQvLyBcdFx0ZGVsZXRlIF9zZWxmLnRyYW5zcG9ydHNbdGlkXTtcblx0XHQvLyBcdH1cblx0XHQvLyB9KTtcblxuXHRcdC8vIF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ0F0dGVtcHRpbmcgdG8gcmVtb3ZlIHNvY2tldC4gJyxzb2NrZXQuX29jdG9wdXMpO1xuXHRcdC8vIF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ0N1cnJlbnQgZW5kcG9pbnRbJXNdWyVzXSB0cmFuc3BvcnRzIGFyZSAuICcsX3NlbGYubGFiZWwsIF9zZWxmLmRpciwgX3NlbGYudHJhbnNwb3J0cyk7XG5cblx0XHRpZiAoc29ja2V0ICYmIHNvY2tldC5fb2N0b3B1cyAmJiBzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cykge1xuXG5cdFx0XHQvLyBHbyB0aHJvdWdoIHRyYW5zcG9ydHMgYWRkZWQgdG8gc29ja2V0XG5cdFx0XHRzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cy5mb3JFYWNoKCh0KSA9PiB7XG5cblx0XHRcdFx0Ly8gU2VlIGlmIGl0cyBhIHRyYW5zcG9ydCBvZiB0aGlzIGVuZHBvaW50XG5cdFx0XHRcdHZhciBmb3VuZFQgPSBPYmplY3Qua2V5cyhfc2VsZi50cmFuc3BvcnRzKS5maW5kKHggPT4gX3NlbGYudHJhbnNwb3J0c1t4XSA9PT0gdCk7XG5cblx0XHRcdFx0Ly8gaWYgZm91bmQsIGRpc2Fzc29jaWF0ZSBmcm9tIHNvY2tldCwgZGVzdHJveSBhbmQgZGVsZXRlIGZyb20gZW5kcG9pbnRcblx0XHRcdFx0aWYgKGZvdW5kVCkge1xuXHRcdFx0XHRcdGZvdW5kVCA9IF9zZWxmLnRyYW5zcG9ydHNbZm91bmRUXTtcblx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIud2FybignRGVzdHJveWluZyAmIHJlbW92aW5nIHRyYW5zcG9ydCBbJXNdIHROYW1lIFslc10gZnJvbSBlbmRwb2ludFslc11bJXNdLiAnLCBmb3VuZFQuaWQsIGZvdW5kVC50TmFtZSwgX3NlbGYubGFiZWwsIF9zZWxmLmRpcik7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSBzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cy5maW5kSW5kZXgoeCA9PiB4ID09IHQpO1xuXHRcdFx0XHRcdHNvY2tldC5fb2N0b3B1cy50cmFuc3BvcnRzLnNwbGljZShpbmRleCwgMSk7XG5cblxuXHRcdFx0XHRcdGZvdW5kVC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0ZGVsZXRlIF9zZWxmLnRyYW5zcG9ydHNbZm91bmRULmlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiAobmFtZXNwYWNlKSB7XG5cblx0XHQvKlxuXHRcdFx0Tk9URSAtIE11c3QgaW52ZXN0aWdhdGUgaWYgdGhlcmUgYXJlIHNpZGUgZWZmZWN0cyA/XG5cblx0XHRcdFNob3VsZCB3ZSBiZSBhbGxvd2VkIHRvIGNoYW5nZSByZW1vdGUgc2lkZSBuYW1lID9cblx0XHRcdFx0QW55IHVzZWNhc2Ugd2hlcmUgd2UgbmVlZCBpdCA/XG5cblx0XHRcdElmIG91ciBuYW1lIGNoYW5nZSBpcyBhY2NlcHRlZCBieSByZW1vdGUgc2lkZSxcblx0XHRcdCBcdHNob3VsZCBpdCB0cmlnZ2VyIG5hbWUgY2hhbmdlcyB3aXRoIG90aGVyIGNvbm5lY3RlZCB0cmFuc3BvcnRzIHRvbyA/IHNpbmNlIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBuYW1lIGZvciB0aGUgcmVtb3RlLlxuXG5cdFx0XHRJZiB3ZSBjaGFuZ2UgdGhlIHJlbW90ZSdzIG5hbWUsXG5cdFx0XHRcdHNob3VsZCBpdCB0cmlnZ2VyIG5hbWUgY2hhbmdlcyB3aXRoIG90aGVyIGNvbm5lY3RlZCB0cmFuc3BvcnRzIHRvbyA/IHNpbmNlIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBuYW1lIGZvciB0aGUgcmVtb3RlLlxuXG5cdFx0XHRJZiBzbyxcblx0XHRcdFx0Q291bGQgdGhpcyBjYXVzZSBpbmZpbml0ZSBsb29wcyAvIHJpcHBsZXMgP1xuXG5cdFx0XHRGb3IgZWcgLSBTYXkgY29ubmVjdGlvbiBwYXRoIGlzIHNldHVwIGFzXG5cdFx0XHRcdEEgLSBCIC0gQyAtIEQgLSBBXG5cdFx0XHRcdCAgICB8X19fX19fX3xcblxuXHRcdCovXG5cdFx0dmFyIF9zZWxmID0gdGhpcztcblx0XHRuYW1lc3BhY2UgPSBuZXcgTmFtZXNwYWNlKG5hbWVzcGFjZSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGFzOiAobmV3TmFtZSkgPT4ge1xuXHRcdFx0XHRfc2VsZi5sYWJlbCA9IG5ld05hbWU7XG5cdFx0XHRcdE9iamVjdC5rZXlzKF9zZWxmLnRyYW5zcG9ydHMpLmZvckVhY2goKHRpZCkgPT4ge1xuXHRcdFx0XHRcdGlmIChuYW1lc3BhY2UudGVzdChfc2VsZi50cmFuc3BvcnRzW3RpZF0udE5hbWUpKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi50cmFuc3BvcnRzW3RpZF0uYXMobmV3TmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qXG5cdCBcdEludGVybmFsIGhvb2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCwgdG8gc2lnbmFsIGEgbmFtZSBjaGFuZ2Vcblx0XHQmIEF1dG9tYXRpY2FsbHkgY2xlYW5zIHVwIGFmdGVyIGl0IGV4ZWN1dGVzIG9uY2UgKHJlc29sdmUgb3IgcmVqZWN0KS5cblx0Ki9cblx0cnBjRW5kcG9pbnQucHJvdG90eXBlLnRyYW5zcG9ydE5hbWVDaGFuZ2VkID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuXG5cdFx0Lypcblx0XHRcdE5PVEUgLSBJbmNsdWRpbmcgYm90aCBleGFjdCAmIE5TIG1hdGNoLCBmb3IgcGVyZm9ybWFuY2UuXG5cdFx0XHR0aGlzIGVuc3VyZXMgdGhhdCBhbnkgZXhhY3QgbWF0Y2ggaXMgcXVpY2tseSBkZXRlY3RlZCBhbmQgcmVzb2x2ZWQgZmlyc3QsXG5cdFx0XHRjYXVzaW5nIG9uZSBsZXNzIHJlZ2V4IG1hdGNoIHRyYW5zYWN0aW9uIChtb3JlIGV4cGVuc2l2ZSkgaW4gdGhlIHN1YnNlcXVlbnQgcm91dGluZS5cblx0XHQqL1xuXG5cdFx0Ly8gUnVuIGFsbCBob29rcyB3aG9zZSBuYW1lc3BhY2UgZXhhY3RseSBtYXRjaGVzIHRyYW5zcG9ydCdzIHROYW1lXG5cdFx0aWYgKHRoaXMubmFtZUNoYW5nZUhvb2tzW3RyYW5zcG9ydC50TmFtZV0pIHtcblx0XHRcdHRoaXMubmFtZUNoYW5nZUhvb2tzW3RyYW5zcG9ydC50TmFtZV0uaG9va3MuZm9yRWFjaCh4ID0+IHgodHJhbnNwb3J0KSk7XG5cdFx0XHRkZWxldGUgdGhpcy5uYW1lQ2hhbmdlSG9va3NbdHJhbnNwb3J0LnROYW1lXTtcblx0XHR9XG5cblx0XHQvLyBBbHNvLCBydW4gYWxsIGhvb2tzIHdob3NlIG5hbWVzcGFjZSBpbmNsdWRlcyB0aGUgdHJhbnNwb3J0J3MgdE5hbWVcblx0XHRPYmplY3Qua2V5cyh0aGlzLm5hbWVDaGFuZ2VIb29rcykubWFwKGsgPT4ge1xuXHRcdFx0aWYgKHRoaXMubmFtZUNoYW5nZUhvb2tzW2tdICYmIHRoaXMubmFtZUNoYW5nZUhvb2tzW2tdLm5zLnRlc3QodHJhbnNwb3J0LnROYW1lKSkge1xuXHRcdFx0XHR0aGlzLm5hbWVDaGFuZ2VIb29rc1trXS5ob29rcy5mb3JFYWNoKHggPT4geCh0cmFuc3BvcnQpKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMubmFtZUNoYW5nZUhvb2tzW2tdO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH07XG5cblx0Lypcblx0XHRSZXR1cm5zIGEgb25lLXRpbWUgaG9vayBwcm9taXNlIHRoYXRcblx0XHRcdDE+IHJlc29sdmVzIHdoZW4gYXBwcm9wcmlhdGUgbmFtZSBjaGFuZ2Ugb2NjdXJzXG5cdFx0XHQyPiByZWplY3RzIGlmIHRpbWVvdXQgaGFwcGVuc1xuXG5cdFx0JiBBdXRvbWF0aWNhbGx5IGNsZWFucyB1cCBpZiBpdCByZWplY3RzICh0aW1lcyBvdXQpLlxuXHRcdENsZWFuIHVwIG9uIHJlc29sdmUgaXMgaGFuZGxlZCBieSB0cmlnZ2VyaW5nIHJvdXRpbmUgZGVjbGFyZWQgYWJvdmUuXG5cdCovXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5hZGRUcmFuc3BvcnROYW1lQ2hhbmdlSG9vayA9IGZ1bmN0aW9uICh0TmFtZSwgdGltZW91dCkge1xuXHRcdGlmICghdGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdKVxuXHRcdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdID0ge1xuXHRcdFx0XHRuczogbmV3IE5hbWVzcGFjZSh0TmFtZSksXG5cdFx0XHRcdGhvb2tzOiBbXVxuXHRcdFx0fTtcblxuXHRcdHZhciBwID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHR2YXIgZm4gPSAodHJhbnNwb3J0KSA9PiB7XG5cdFx0XHRcdGlmIChyZXMgJiYgIXAuZG9uZSkge1xuXHRcdFx0XHRcdHAuZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0Ly8gdmFyIGkgPSB0aGlzLm5hbWVDaGFuZ2VIb29rc1t0TmFtZV0uaG9va3MuZmluZEluZGV4KHggPT4geCA9PSBmbik7XG5cdFx0XHRcdFx0Ly8gdGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLmhvb2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRyZXModHJhbnNwb3J0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLmhvb2tzLnB1c2goZm4pO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0aWYgKHJlaiAmJiAhcC5kb25lKSB7XG5cdFx0XHRcdFx0cC5kb25lID09IHRydWU7XG5cdFx0XHRcdFx0dmFyIGkgPSB0aGlzLm5hbWVDaGFuZ2VIb29rc1t0TmFtZV0uaG9va3MuZmluZEluZGV4KHggPT4geCA9PSBmbik7XG5cdFx0XHRcdFx0dGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLmhvb2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRpZiAodGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdLmhvb2tzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5uYW1lQ2hhbmdlSG9va3NbdE5hbWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZWooKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGltZW91dCB8fCA1MDAwKTtcblxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHA7XG5cdH07XG5cblx0cnBjRW5kcG9pbnQucHJvdG90eXBlLmRpc3BsYXlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIF9zZWxmID0gdGhpcztcblx0XHR2YXIgbG9nU3RyaW5nID0gJ2tleVxcdFxcdFxcdG5hbWVcXHRcXHRcXHR0eXBlOmlkXFx0XFx0XFx0aW5pdGFsaXNlZFxcbic7XG5cdFx0T2JqZWN0LmtleXMoX3NlbGYudHJhbnNwb3J0cykuZm9yRWFjaCgodEtleSkgPT4ge1xuXHRcdFx0bG9nU3RyaW5nICs9IGAke3RLZXl9XFx0XFx0JHtfc2VsZi50cmFuc3BvcnRzW3RLZXldLnROYW1lfVxcdFxcdCR7X3NlbGYudHJhbnNwb3J0c1t0S2V5XS50eXBlICsnOicrX3NlbGYudHJhbnNwb3J0c1t0S2V5XS5pZH1cXHRcXHQke19zZWxmLnRyYW5zcG9ydHNbdEtleV0uaW5pdGlhbGlzZWR9XFxuYDtcblx0XHR9KTtcblx0XHRyZXR1cm4gbG9nU3RyaW5nO1xuXHR9O1xuXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5jb21tYW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IHJwY0NvbW1hbmQobmFtZSwgdGhpcywgeyBsb2dnZXI6IHRoaXMubG9nZ2VyIH0pO1xuXHR9O1xuXG5cdC8vIFJldHVybnMgdGhlIGZpcnN0IHRyYW5zcG9ydCB0aGF0J3MgYW4gZXhhY3QgbWF0Y2ggYnkgdE5hbWVcblx0cnBjRW5kcG9pbnQucHJvdG90eXBlLmZpbmRUcmFuc3BvcnRCeU5hbWUgPSBmdW5jdGlvbiAodE5hbWUpIHtcblx0XHR2YXIgdEtleSA9IE9iamVjdC5rZXlzKHRoaXMudHJhbnNwb3J0cykuZmluZCh4ID0+IHRoaXMudHJhbnNwb3J0c1t4XS50TmFtZSA9PSB0TmFtZSk7XG5cblx0XHRpZiAodEtleSlcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zcG9ydHNbdEtleV07XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0Ly8gUmV0dXJucyBhbGwgdHJhbnNwb3J0cyB0aGF0IGZhbGwgd2l0aGluIGEgZ2l2ZW4gbmFtZXNwYWNlXG5cdHJwY0VuZHBvaW50LnByb3RvdHlwZS5maW5kVHJhbnNwb3J0c0J5TmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0dmFyIG5zID0gbmV3IE5hbWVzcGFjZShuYW1lc3BhY2UpO1xuXHRcdHZhciB0cmFuc3BvcnRzID0gT2JqZWN0LmtleXModGhpcy50cmFuc3BvcnRzKVxuXHRcdFx0Lm1hcCh4ID0+IHRoaXMudHJhbnNwb3J0c1t4XSk7XG5cblxuXHRcdGlmIChvcHRpb25zLmludGlhbGlzZWQgPT09IHRydWUpIHtcblx0XHRcdHRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzLmZpbHRlcih0ID0+IHQuaW5pdGlhbGlzZWQgPT09IHRydWUpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRyYW5zcG9ydHNcblx0XHRcdC5maWx0ZXIodCA9PiBucy50ZXN0KHQudE5hbWUpKVxuXG5cdH07XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5cdG1vZHVsZS5leHBvcnRzID0gcnBjRW5kcG9pbnQ7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXHR2YXIgaWRDb3VudCA9IDA7XG5cdHZhciBhdXRvSUQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICdUJyArICgrK2lkQ291bnQpO1xuXHR9O1xuXG5cdHZhciBycGNUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHlwZSwgc29ja2V0LCBlbmRwb2ludCwgb3B0aW9ucykge1xuXHRcdC8vIGNvbnNvbGUubG9nKCdDcmVhdGluZyBycGMgdHJhbnNwb3J0IFslc10gZm9yIGVuZHBvaW50IFslc11bJXNdJyx0eXBlLCBlbmRwb2ludC5sYWJlbCwgZW5kcG9pbnQuZGlyKTtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgX3NlbGYgPSB0aGlzO1xuXG5cdFx0X3NlbGYuaWQgPSBhdXRvSUQoKTtcblx0XHRfc2VsZi5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlci5jaGlsZCgnVDonICsgdHlwZSArICc6JyArIF9zZWxmLmlkKTtcblxuXHRcdF9zZWxmLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG5cdFx0X3NlbGYudHlwZSA9IHR5cGU7XG5cdFx0X3NlbGYuc29ja2V0ID0gc29ja2V0OyAvLyBBbHNvIHVzZWQgZm9yIG1hdGNoaW5nICYgcmVtb3ZhbCwgYmVzaWRlcyBpbnRlcm5hbCBzb2NrZXQgYWNjZXNzLlxuXHRcdF9zZWxmLnROYW1lID0gJ25vbm5hbWUnO1xuXHRcdF9zZWxmLmluaXRpYWxpc2VkID0gZmFsc2U7XG5cdFx0X3NlbGYuZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRfc2VsZi5uYW1lQ2xvY2sgPSAwO1xuXHRcdF9zZWxmLmRpckZsaXAgPSB7XG5cdFx0XHRpOiAnbycsXG5cdFx0XHRvOiAnaSdcblx0XHR9O1xuXG5cdFx0Ly8gQWRkIHRyYXNwb3J0IHR5cGUgc3BlY2lmaWMgbWV0aG9kcyB0byBzZWxmXG5cdFx0T2JqZWN0LmFzc2lnbihfc2VsZiwgX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0VHlwZXNbdHlwZV0odHlwZSwgc29ja2V0KSk7XG5cdFx0aWYoIXNvY2tldC5fb2N0b3B1cylcblx0XHRcdHNvY2tldC5fb2N0b3B1cyA9IHt9O1xuXG5cdFx0aWYoIXNvY2tldC5fb2N0b3B1cy50cmFuc3BvcnRzKVxuXHRcdFx0c29ja2V0Ll9vY3RvcHVzLnRyYW5zcG9ydHMgPSBbXTtcblxuXHRcdGlmKCFzb2NrZXQuX29jdG9wdXMudHJhbnNwb3J0cy5pbmNsdWRlcyh0aGlzKSlcblx0XHRcdHNvY2tldC5fb2N0b3B1cy50cmFuc3BvcnRzLnB1c2godGhpcyk7XG5cblx0XHRfc2VsZi5pbml0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0X3NlbGYucmVjdkhhbmRsZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuXG5cdFx0XHRcdC8vIEFib3J0IGlmIHdlJ3JlIGRpc2FibGVkXG5cdFx0XHRcdGlmKF9zZWxmLmRpc2FibGVkKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXG5cdFx0XHRcdC8vIF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ1tvblJlY3ZdIERhdGEgcmVjdmQgb24gWyVzXVslc10nLF9zZWxmLnROYW1lLF9zZWxmLmVuZHBvaW50LmRpciwgZGF0YSk7XG5cdFx0XHRcdGlmIChkYXRhLnJwY19kaXIgPT0gX3NlbGYuZGlyRmxpcFtfc2VsZi5lbmRwb2ludC5kaXJdKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1tvblJlY3ZdIERhdGEgYWNjZXB0ZWQgb24gWyVzXVslc10nLF9zZWxmLnROYW1lLF9zZWxmLmVuZHBvaW50LmRpciwgZGF0YSk7XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5ycGNfdE5hbWVfY2hhbmdlKSB7XG5cdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHROT1RFIC0gSW1wbGVtZW50aW5nIFwiTGF0ZXN0ICYgbGFzdCB3cml0ZSB3aW5zXCIgY29uc2Vuc3VzIHBvbGljeSA6XG5cdFx0XHRcdFx0XHRcdFx0V0hZID8gLSBSZXF1aXJlZCB0byBzb2x2ZSBkaXNwdXRlcyB3aGVuIGJvdGgob3IgbW9yZSkgZW5kcG9pbnRzIHJlcXVlc3QgYSBuYW1lIGNoYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxuXHRcdFx0XHRcdFx0XHRcdFdpdGhvdXQgdGhpcywgYSBzaW11bHRhbmVvdXMgcmVxdWVzdCBjYXVzZXMgZWFjaCBvbmUgdG8gc2VuZHMgaGlzIG5hbWUgY2hhbmdlIG92ZXIgd2hpbGUgaW1wbGVtZW50aW5nIHRoZSBvdGhlcidzIG5hbWUgY2hhbmdlIHJlcXVlc3QuXG5cdFx0XHRcdFx0XHRcdFx0IFx0Y29uc2VxdWVuY2UgLSBhIG5hbWUgc3dhcCwgaW5zdGVhZCBvZiBjb25zZW5zdXMgb24gYSBzaW5nbGUgbmFtZSB2YWx1ZS5cblx0XHRcdFx0XHRcdCovXG5cblx0XHRcdFx0XHRcdGlmKGRhdGEucnBjX3ROYW1lX2NoYW5nZS5yZXF1ZXN0ID09IHRydWUpe1xuXHRcdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHRcdE9wcG9zaXRlIHBhcnR5IGhhcyByZXF1ZXN0ZWQgYSBuYW1lIGNoYW5nZSB0cmFuc2FjdGlvbiwgdG8gYmUgaW5pdGlhdGVkIGZyb20gaGVyZS5cblx0XHRcdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnTmFtZSBjaGFuZ2UgcmVxdWVzdGVkIGJ5IHJlbW90ZS4gSW5pdGlhdGluZyB0cmFuc2FjdGlvbi4uLicsX3NlbGYudE5hbWUpO1xuXG5cdFx0XHRcdFx0XHRcdF9zZWxmLmFzKF9zZWxmLnROYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGRhdGEucnBjX3ROYW1lX2NoYW5nZS5hY2sgPT0gdHJ1ZSkge1xuXG5cdFx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHRcdFx0T3Bwb3NpdGUgcGFydHkgaGFzIGFjY2VwdGVkIHRoZSBuYW1lIGNoYW5nZSB0aGF0IHdlIHByb3Bvc2VkLlxuXHRcdFx0XHRcdFx0XHRcdEh1cnJheS4gU2lnbmFsIG5hbWVjaGFuZ2UgdG8gZW5kcG9pbnQgJiByZXNvbHZlLlxuXHRcdFx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdOYW1lIGNoYW5nZSB0byBbJXNdIGFja25vd2xlZGdlZC4nLF9zZWxmLnROYW1lKTtcblxuXHRcdFx0XHRcdFx0XHRfc2VsZi5lbmRwb2ludC50cmFuc3BvcnROYW1lQ2hhbmdlZChfc2VsZik7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFfc2VsZi5pbml0aWFsaXNlZCkge1xuXHRcdFx0XHRcdFx0XHRcdF9zZWxmLmluaXRpYWxpc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdjaGFuZ2VkIGluaXRpYWxpc2VkIHN0YXR1cyBmcm9tIGZhbHNlIHRvIHRydWUnKTtcblx0XHRcdFx0XHRcdFx0XHRyZXMoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChkYXRhLnJwY190TmFtZV9jaGFuZ2UuZm9yY2UgfHwgZGF0YS5ycGNfdE5hbWVfY2hhbmdlLmNsb2NrID49IF9zZWxmLm5hbWVDbG9jaykge1xuXG5cdFx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHRcdFx0T3Bwb3NpdGUgcGFydHkncyBjbG9jayBpcyBoaWdoZXIgb3IgaGFzIGFscmVhZHkgcmVhY2hlZCB0aGUgc2FtZSBsZXZlbCAoaWUgYmVmb3JlIHVzKS5cblx0XHRcdFx0XHRcdFx0XHRBY2NlcHQgdGhlaXIgcHJvcG9zYWwsIHNlbmQgYWNrLCBzaWduYWwgbmFtZWNoYW5nZSB0byBlbmRwb2ludFxuXHRcdFx0XHRcdFx0XHQqL1xuXG5cdFx0XHRcdFx0XHRcdF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ1slcywgY2xvY2sgJXNdIFslc10gQ2hhbmdpbmcgbmFtZSBvZiB0cmFuc3BvcnQgWyVzXVslc10gdG8gWyVzXSBhdCBjbG9jayA9JywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIF9zZWxmLm5hbWVDbG9jaywgZGF0YS5ycGNfdE5hbWVfY2hhbmdlLmZvcmNlID8gJ2ZvcmNlZCcgOiAnJywgX3NlbGYudE5hbWUsIF9zZWxmLmlkLCBkYXRhLnJwY190TmFtZV9jaGFuZ2UudE5hbWUsIGRhdGEucnBjX3ROYW1lX2NoYW5nZS5jbG9jayk7XG5cdFx0XHRcdFx0XHRcdC8vIGRlbGV0ZSBfc2VsZi5lbmRwb2ludC50cmFuc3BvcnRzW19zZWxmLnROYW1lXTtcblx0XHRcdFx0XHRcdFx0X3NlbGYudE5hbWUgPSBkYXRhLnJwY190TmFtZV9jaGFuZ2UudE5hbWU7XG5cdFx0XHRcdFx0XHRcdF9zZWxmLm5hbWVDbG9jayA9IGRhdGEucnBjX3ROYW1lX2NoYW5nZS5jbG9jaztcblx0XHRcdFx0XHRcdFx0Ly8gX3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1tfc2VsZi50TmFtZV0gPSBfc2VsZjtcblxuXHRcdFx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdOYW1lIGNoYW5nZSB0byBbJXNdIGFjY2VwdGVkLicsX3NlbGYudE5hbWUpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlbmQgYWNrXG5cdFx0XHRcdFx0XHRcdF9zZWxmLnNlbmQoe1xuXHRcdFx0XHRcdFx0XHRcdHJwY190TmFtZV9jaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHROYW1lOiBfc2VsZi50TmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb2NrOiBfc2VsZi5uYW1lQ2xvY2ssXG5cdFx0XHRcdFx0XHRcdFx0XHRhY2s6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdHJwY19kaXI6IF9zZWxmLmVuZHBvaW50LmRpclxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRfc2VsZi5lbmRwb2ludC50cmFuc3BvcnROYW1lQ2hhbmdlZChfc2VsZik7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFfc2VsZi5pbml0aWFsaXNlZCkge1xuXHRcdFx0XHRcdFx0XHRcdF9zZWxmLmluaXRpYWxpc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRyZXMoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHRcdFx0T3VyIGNsb2NrIGlzIGhpZ2hlciwgc28gZG9uJ3QgYWNjZXB0LlxuXHRcdFx0XHRcdFx0XHRcdFByb3Bvc2Ugb3VyIG5hbWUgaW5zdGVhZC5cblx0XHRcdFx0XHRcdFx0Ki9cblxuXHRcdFx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdbJXMsIGNsb2NrICVzXSBbJXNdIFJlamVjdGluZyBuYW1lIGNoYW5nZSBvZiB0cmFuc3BvcnQgWyVzXVslc10gYXMgWyVzXSBhdCBjbG9jayA9JywgX3NlbGYuZW5kcG9pbnQubGFiZWwsIF9zZWxmLm5hbWVDbG9jaywgZGF0YS5ycGNfdE5hbWVfY2hhbmdlLmZvcmNlID8gJ2ZvcmNlZCcgOiAnJywgX3NlbGYudE5hbWUsIF9zZWxmLmlkLCBkYXRhLnJwY190TmFtZV9jaGFuZ2UudE5hbWUsIGRhdGEucnBjX3ROYW1lX2NoYW5nZS5jbG9jayk7XG5cdFx0XHRcdFx0XHRcdF9zZWxmLnNlbmQoe1xuXHRcdFx0XHRcdFx0XHRcdHJwY190TmFtZV9jaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHROYW1lOiBfc2VsZi50TmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb2NrOiBfc2VsZi5uYW1lQ2xvY2ssXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3JjZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0cnBjX2RpcjogX3NlbGYuZW5kcG9pbnQuZGlyXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhLnJwY19tc2cpIHtcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0T2JqZWN0LmtleXMoZGF0YS5ycGNfbXNnKS5mb3JFYWNoKChjS2V5KSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKF9zZWxmLmVuZHBvaW50LmNvbW1hbmRzW2NLZXldKXtcblx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gX3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnW29uUmVjdl0gRGF0YSByZWN2ZCBvbiBbJXNdWyVzXScsX3NlbGYudE5hbWUsX3NlbGYuZW5kcG9pbnQuZGlyLCBkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRfc2VsZi5lbmRwb2ludC5jb21tYW5kc1tjS2V5XS5yZWNpZXZlKGRhdGEucnBjX21zZ1tjS2V5XSwgX3NlbGYpXG5cdFx0XHRcdFx0XHRcdFx0LmNhdGNoKChlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIuZXJyb3IoJ1slc10gRmFpbGVkIHRvIHJlc3BvbmQgdG8gWyVzXSByZXF1ZXN0IChyZWdpc3RlcmVkKSBmcm9tIFslc10gYmVjYXVzZSAtICAnLCBfc2VsZi5lbmRwb2ludC5sYWJlbCwgY0tleSwgX3NlbGYudE5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgdGVtcCBjb21tYW5kIGFuZCBwcm9jZXNzLlxuXHRcdFx0XHRcdFx0XHRcdF9zZWxmLmVuZHBvaW50LmNvbW1hbmQoY0tleSkucmVjaWV2ZShkYXRhLnJwY19tc2dbY0tleV0sIF9zZWxmKVxuXHRcdFx0XHRcdFx0XHRcdC5jYXRjaCgoZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmVycm9yKCdbJXNdIEZhaWxlZCB0byByZXNwb25kIHRvIFslc10gcmVxdWVzdCAodGVtcG9yYXJ5KSBmcm9tIFslc10gYmVjYXVzZSAtICAnLCBfc2VsZi5lbmRwb2ludC5sYWJlbCwgY0tleSwgX3NlbGYudE5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRfc2VsZi5vblJlY3YoX3NlbGYucmVjdkhhbmRsZXIpO1xuXG5cdFx0XHRfc2VsZi5kZXN0cm95ID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly8gX3NlbGYubG9nZ2VyLmVuYWJsZWQgJiYgX3NlbGYubG9nZ2VyLmxvZygnWyVzXSBEZXN0cm95aW5nIHRyYW5zcG9ydCBbJXNdID0nLCBfc2VsZi5lbmRwb2ludC5sYWJlbCwgX3NlbGYudE5hbWUpO1xuXHRcdFx0XHRfc2VsZi5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRcdF9zZWxmLnNvY2tldCA9IG51bGw7XG5cblx0XHRcdFx0aWYoX3NlbGYuc3RvcFJlY3Ype1xuXHRcdFx0XHRcdC8vIF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ1slc10gRGVzdHJveWluZyB0cmFuc3BvcnQgWyVzXSAtIHN0b3BSZWN2IGZvdW5kID0nLCBfc2VsZi5lbmRwb2ludC5sYWJlbCwgX3NlbGYudE5hbWUpO1xuXHRcdFx0XHRcdF9zZWxmLnN0b3BSZWN2KF9zZWxmLnJlY3ZIYW5kbGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuYXMgPSBmdW5jdGlvbiAodE5hbWUpIHtcblx0XHRcdFx0Ly8gZGVsZXRlIF9zZWxmLmVuZHBvaW50LnRyYW5zcG9ydHNbX3NlbGYudE5hbWVdO1xuXHRcdFx0XHR2YXIgcHJldk5hbWUgPSBfc2VsZi50TmFtZTtcblx0XHRcdFx0X3NlbGYudE5hbWUgPSB0TmFtZTtcblx0XHRcdFx0X3NlbGYubmFtZUNsb2NrKys7XG5cdFx0XHRcdF9zZWxmLmxvZ2dlci5lbmFibGVkICYmIF9zZWxmLmxvZ2dlci5sb2coJ1slc10gU2VuZGluZyBuYW1lY2hhbmdlIG9mIHRyYW5zcG9ydCBbJXNdWyVzXSB0byBbJXNdIGF0IGNsb2NrID0nLCBfc2VsZi5lbmRwb2ludC5sYWJlbCwgcHJldk5hbWUsIHROYW1lLCBfc2VsZi5pZCwgX3NlbGYubmFtZUNsb2NrKTtcblx0XHRcdFx0X3NlbGYuc2VuZCh7XG5cdFx0XHRcdFx0cnBjX3ROYW1lX2NoYW5nZToge1xuXHRcdFx0XHRcdFx0dE5hbWU6IF9zZWxmLnROYW1lLFxuXHRcdFx0XHRcdFx0Y2xvY2s6IF9zZWxmLm5hbWVDbG9ja1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cnBjX2RpcjogX3NlbGYuZW5kcG9pbnQuZGlyXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyAvLyBfc2VsZi5lbmRwb2ludC50cmFuc3BvcnRzW3ROYW1lXSA9IF9zZWxmO1xuXHRcdFx0XHQvLyBpZighX3NlbGYuaW5pdGlhbGlzZWQpIHtcblx0XHRcdFx0Ly8gXHRfc2VsZi5pbml0aWFsaXNlZCA9IHRydWU7XG5cdFx0XHRcdC8vIFx0cmVzKCk7XG5cdFx0XHRcdC8vIH1cblx0XHRcdFx0cmV0dXJuIF9zZWxmO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVHJpZ2dlcnMgYW4gJy5hcygpJyBmdW5jdGlvbiBvbiB0aGUgcmVtb3RlIGVuZCBvZiB0aGUgc29ja2V0LlxuXHRcdFx0X3NlbGYuYXNSZW1vdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdSZXF1ZXN0aW5nIG5hbWVjaGFuZ2UgZnJvbSByZW1vdGUsIGF0IGNsb2NrID0nLCBfc2VsZi5uYW1lQ2xvY2spO1xuXHRcdFx0XHRfc2VsZi5zZW5kKHtcblx0XHRcdFx0XHRycGNfdE5hbWVfY2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0OnRydWVcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJwY19kaXI6IF9zZWxmLmVuZHBvaW50LmRpclxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gX3NlbGY7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0X3NlbGYuZW5kcG9pbnQudHJhbnNwb3J0c1tfc2VsZi5pZF0gPSBfc2VsZjtcblx0XHRfc2VsZi5sb2dnZXIuZW5hYmxlZCAmJiBfc2VsZi5sb2dnZXIubG9nKCdBZGRlZCB0cmFuc3BvcnQgWyVzXVslc10gZm9yIGVuZHBvaW50IFslc11bJXNdJywgdHlwZSwgX3NlbGYuaWQsIGVuZHBvaW50LmxhYmVsLCBlbmRwb2ludC5kaXIpO1xuXHRcdHJldHVybiBfc2VsZjtcblx0fTtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBycGNUcmFuc3BvcnQ7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuXG5cdHZhciB0cmFuc3BvcnRUeXBlcyA9IHt9O1xuXG5cdHRyYW5zcG9ydFR5cGVzWydzb2NrZXRpbyddID0gZnVuY3Rpb24gKHR5cGUsIHNvY2tldCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiAoZGF0YSkgPT4gc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxuXHRcdFx0b25SZWN2OiAoZm4pID0+IHNvY2tldC5vbignbWVzc2FnZScsIChkYXRhKSA9PiBmbihKU09OLnBhcnNlKGRhdGEpKSksXG5cdFx0XHRzdG9wUmVjdjogKGZuKSA9PiBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcblx0XHR9XG5cdH07XG5cdHRyYW5zcG9ydFR5cGVzWyd3ZWJzb2NrZXQnXSA9IGZ1bmN0aW9uICh0eXBlLCBzb2NrZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogKGRhdGEpID0+IHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0XHRcdHNvY2tldC5zZW5kKFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoZGF0YSksXG5cdFx0XHRcdFx0XHQoZSkgPT4gZSA/IHJlaihlKSA6IHJlcygpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0b25SZWN2OiAoZm4pID0+IHNvY2tldC5vbignbWVzc2FnZScsIChkYXRhKSA9PiBmbihKU09OLnBhcnNlKGRhdGEpKSksXG5cdFx0XHRzdG9wUmVjdjogKGZuKSA9PiBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcblx0XHR9XG5cdH07XG5cdHRyYW5zcG9ydFR5cGVzWydwcm9jZXNzTG9jYWwnXSA9IGZ1bmN0aW9uICh0eXBlLCBzb2NrZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogKGRhdGEpID0+IHNvY2tldC5lbWl0KCdtZXNzYWdlJywgSlNPTi5zdHJpbmdpZnkoZGF0YSkpLFxuXHRcdFx0b25SZWN2OiAoZm4pID0+IHNvY2tldC5vbignbWVzc2FnZScsIChkYXRhKSA9PiBmbihKU09OLnBhcnNlKGRhdGEpKSksXG5cdFx0XHRzdG9wUmVjdjogKGZuKSA9PiBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcblx0XHR9XG5cdH07XG5cdHRyYW5zcG9ydFR5cGVzWydub2RlRUVMb2NhbCddID0gZnVuY3Rpb24gKHR5cGUsIHNvY2tldCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiAoZGF0YSkgPT4gc29ja2V0LmVtaXQoJ21lc3NhZ2UnLCBKU09OLnN0cmluZ2lmeShkYXRhKSksXG5cdFx0XHRvblJlY3Y6IChmbikgPT4gc29ja2V0Lm9uKCdtZXNzYWdlJywgKGRhdGEpID0+IGZuKEpTT04ucGFyc2UoZGF0YSkpKSxcblx0XHRcdHN0b3BSZWN2OiAoZm4pID0+IHNvY2tldC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuXHRcdH1cblx0fTtcblx0dHJhbnNwb3J0VHlwZXNbJ3Byb2Nlc3NSZW1vdGUnXSA9IGZ1bmN0aW9uICh0eXBlLCBzb2NrZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogKGRhdGEpID0+IHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0XHRcdHZhciBzID0gc29ja2V0LnNlbmQoXG5cdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShkYXRhKSxcblx0XHRcdFx0XHRcdChlKSA9PiBlIGluc3RhbmNlb2YgRXJyb3IgPyByZWooZSkgOiAocyA9PT0gdHJ1ZSA/IHJlcyhzKSA6IHJlaihzKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRvblJlY3Y6IChmbikgPT4gc29ja2V0Lm9uKCdtZXNzYWdlJywgKGRhdGEpID0+IGZuKEpTT04ucGFyc2UoZGF0YSkpKSxcblx0XHRcdHN0b3BSZWN2OiAoZm4pID0+IHNvY2tldC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuXHRcdH1cblx0fTtcblx0dHJhbnNwb3J0VHlwZXNbJ25vZGVFRVJlbW90ZSddID0gZnVuY3Rpb24gKHR5cGUsIHNvY2tldCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiAoZGF0YSkgPT4gc29ja2V0LnNlbmQoJ21lc3NhZ2UnLCBKU09OLnN0cmluZ2lmeShkYXRhKSksXG5cdFx0XHRvblJlY3Y6IChmbikgPT4gc29ja2V0Lm9uKCdtZXNzYWdlJywgKGRhdGEpID0+IGZuKEpTT04ucGFyc2UoZGF0YSkpKSxcblx0XHRcdHN0b3BSZWN2OiAoZm4pID0+IHNvY2tldC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuXHRcdH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydFR5cGVzO1xuXG59KSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZWJ1Zyl7XG5cblx0dmFyIGxvZ2dlciA9IGZ1bmN0aW9uIChzdWZmaXgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnByZWZpeCA9IHN1ZmZpeCB8fCAnJztcblxuXHRcdGlmKHR5cGVvZiBkZWJ1ZyA9PSAnZnVuY3Rpb24nKXtcblx0XHRcdHRoaXMubG9nID0gZGVidWcoYGxvZ3M6YCArIHRoaXMucHJlZml4KTtcblx0XHRcdHRoaXMud2FybiA9IGRlYnVnKGB3YXJuaW5nczpgICsgdGhpcy5wcmVmaXgpO1xuXHRcdFx0dGhpcy5lcnJvciA9IGRlYnVnKGBlcnJvcnM6YCArIHRoaXMucHJlZml4KTtcblx0XHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHR0aGlzLmxvZyA9ICgpPT57fTtcblx0XHRcdHRoaXMud2FybiA9ICgpPT57fTtcblx0XHRcdHRoaXMuZXJyb3IgPSAoKT0+e307XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0bG9nZ2VyLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChzdWZmaXgpIHtcblx0XHRyZXR1cm4gbmV3IGxvZ2dlcih0aGlzLnByZWZpeCArICc6JyArIHN1ZmZpeCk7XG5cdH07XG5cblx0cmV0dXJuIGxvZ2dlcjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZWJ1Zykge1xuXG5cdGNvbnN0IE5hbWVzcGFjZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9uYW1lc3BhY2UuanMnKTtcblx0Y29uc3QgcnBjRW5kcG9pbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvcnBjRW5kcG9pbnQuanMnKTtcblx0Y29uc3QgZGVidWdyID0gcmVxdWlyZSgnZGVidWctcGVzdCcpKGRlYnVnKTtcblx0dmFyIGFwcExvZ2dlciA9IG5ldyBkZWJ1Z3IoJ29jdG9wdXMnKTtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHZhciBycGNzID0ge307XG5cblx0dmFyIHJwYyA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblxuXHRcdGlmIChvcHRpb25zLmNyZWF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMuY29tbWFuZHMgPSB7fTtcblx0XHRcdHRoaXMubG9nZ2VyID0gYXBwTG9nZ2VyLmNoaWxkKHRoaXMubmFtZSk7XG5cblx0XHRcdHRoaXMuaW5jb21pbmcgPSBuZXcgcnBjRW5kcG9pbnQobmFtZSwgJ2knLCB7IGxvZ2dlcjogdGhpcy5sb2dnZXIgfSk7XG5cdFx0XHR0aGlzLm91dGdvaW5nID0gbmV3IHJwY0VuZHBvaW50KG5hbWUsICdvJywgeyBsb2dnZXI6IHRoaXMubG9nZ2VyIH0pO1xuXG5cdFx0XHR0aGlzLmxvZ2dlci5lbmFibGVkICYmIHRoaXMubG9nZ2VyLmxvZygnQ3JlYXRlZCBuZXcgT2N0b3B1cyBSUEMgYXMgJywgdGhpcy5uYW1lKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghcnBjc1tuYW1lXSkge1xuXHRcdFx0b3B0aW9ucy5jcmVhdGUgPSB0cnVlO1xuXHRcdFx0cnBjc1tuYW1lXSA9IG5ldyBycGMobmFtZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cblx0XHRyZXR1cm4gcnBjc1tuYW1lXTtcblxuXHR9O1xuXHRycGMucHJvdG90eXBlLmRpc3BsYXlUcmFuc3BvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG4tLS0tLS0gVHJhbnNwb3J0cyBmb3IgWyVzXSBhcmU6XFxuJywgdGhpcy5uYW1lKTtcblx0XHQvLyBjb25zb2xlLmxvZygnaW5jb21pbmc6XFxuJyk7XG5cdFx0Ly8gdGhpcy5pbmNvbWluZy5kaXNwbGF5VHJhbnNwb3J0cygpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdcXG5cXG5vdXRnb2luZzpcXG4nKTtcblx0XHQvLyB0aGlzLm91dGdvaW5nLmRpc3BsYXlUcmFuc3BvcnRzKCk7XG5cdFx0Ly8gY29uc29sZS5sb2coJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuJyk7XG5cblx0XHR2YXIgbG9nU3RyaW5nID0gYFxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSBUUkFOU1BPUlRTIGZvciBbJHt0aGlzLm5hbWV9XSBhcmUgOiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuSW5jb21pbmcgKHByb3ZpZGVzKTpcblxuYDtcblxuXHRcdGxvZ1N0cmluZyArPSB0aGlzLmluY29taW5nLmRpc3BsYXlTdHJpbmcoKTtcblx0XHRsb2dTdHJpbmcgKz0gYFxcblxcbi0tLS0tLS0tLS0tLS1cXG5PdXRnb2luZyAoY2FsbHMpOlxcblxcbmA7XG5cdFx0bG9nU3RyaW5nICs9IHRoaXMub3V0Z29pbmcuZGlzcGxheVN0cmluZygpO1xuXHRcdGxvZ1N0cmluZyArPSAnXFxuXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuJztcblxuXHRcdGNvbnNvbGUubG9nKGxvZ1N0cmluZyk7XG5cdH07XG5cblx0cnBjLnByb3RvdHlwZS5vdmVyID0gZnVuY3Rpb24gKHNvY2tldCwgdHlwZSkge1xuXHRcdHZhciB0YXNrcyA9IFtdO1xuXHRcdHRhc2tzLnB1c2goXG5cdFx0XHR0aGlzLmluY29taW5nLm92ZXIoc29ja2V0LCB0eXBlKVxuXHRcdFx0LmFzKHRoaXMubmFtZSlcblx0XHRcdC5pbml0UHJvbWlzZVxuXHRcdCk7XG5cdFx0dGFza3MucHVzaChcblx0XHRcdHRoaXMub3V0Z29pbmcub3Zlcihzb2NrZXQsIHR5cGUpXG5cdFx0XHQuYXNSZW1vdGUoKVxuXHRcdFx0LmluaXRQcm9taXNlXG5cdFx0KTtcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwodGFza3MpO1xuXHR9O1xuXHRycGMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcblx0XHR0aGlzLmluY29taW5nLnJlbW92ZShzb2NrZXQpO1xuXHRcdHRoaXMub3V0Z29pbmcucmVtb3ZlKHNvY2tldCk7XG5cdH07XG5cblx0cnBjLnByb3RvdHlwZS5wbHVnaW5UcmFuc3BvcnRzID0gZnVuY3Rpb24gKHRPYmopIHtcblx0XHR0aGlzLmluY29taW5nLnBsdWdpblRyYW5zcG9ydHModE9iaik7XG5cdFx0dGhpcy5vdXRnb2luZy5wbHVnaW5UcmFuc3BvcnRzKHRPYmopO1xuXHR9O1xuXHRycGMucHJvdG90eXBlLmNvbW1hbmQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBfc2VsZiA9IHRoaXM7XG5cdFx0aWYgKCFfc2VsZi5jb21tYW5kc1tuYW1lXSkge1xuXHRcdFx0dmFyIGlDID0gX3NlbGYuaW5jb21pbmcuY29tbWFuZChuYW1lKTtcblx0XHRcdHZhciBvQyA9IF9zZWxmLm91dGdvaW5nLmNvbW1hbmQobmFtZSk7XG5cdFx0XHRfc2VsZi5NRVNTQUdFVFlQRVMgPSBpQy5NRVNTQUdFVFlQRVMgfHwgb0MuTUVTU0FHRVRZUEVTO1xuXG5cdFx0XHRfc2VsZi5jb21tYW5kc1tuYW1lXSA9IHtcblx0XHRcdFx0cHJvdmlkZTogZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRcdFx0aUMucHJvdmlkZShmbik7XG5cdFx0XHRcdFx0cmV0dXJuIF9zZWxmLmNvbW1hbmRzW25hbWVdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1blByb3ZpZGU6IGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRcdGlDLnVuUHJvdmlkZShmbik7XG5cdFx0XHRcdFx0cmV0dXJuIF9zZWxmLmNvbW1hbmRzW25hbWVdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvblByb3ZpZGU6IGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRcdGlDLm9uUHJvdmlkZShmbik7XG5cdFx0XHRcdFx0cmV0dXJuIF9zZWxmLmNvbW1hbmRzW25hbWVdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYWxsOiBmdW5jdGlvbiAoZmlsdGVyLCBkYXRhKSB7XG5cdFx0XHRcdFx0Ly8gX3NlbGYuZGlzcGxheVRyYW5zcG9ydHMoKTtcblx0XHRcdFx0XHRyZXR1cm4gb0MuY2FsbChmaWx0ZXIsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jb21tYW5kc1tuYW1lXTtcblx0fTtcblx0cnBjLnByb3RvdHlwZS5yZW5hbWVUbyA9IGZ1bmN0aW9uIChuZXdOYW1lKSB7XG5cdFx0dGhpcy5pbmNvbWluZy5yZW5hbWUodGhpcy5uYW1lKVxuXHRcdFx0LmFzKG5ld05hbWUpO1xuXHRcdHRoaXMubmFtZSA9IG5ld05hbWU7XG5cdFx0Ly8gdGhpcy5vdXRnb2luZy5sYWJlbCA9IG5ld05hbWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tICBSZXN1bHQgcGFyc2luZyAmIFJlc29sdmluZyB0byBQcm9taXNlIHJlc29sdmUvcmVqZWN0IC0tLS0tLS0tLS0tKi9cblxuXHRycGMucHJvdG90eXBlLnBhcnNlQnlTdGF0dXMgPSBmdW5jdGlvbiAocmVzKSB7XG5cdFx0dmFyIHZhbGlkcyA9IFtdLFxuXHRcdFx0aW52YWxpZHMgPSBbXSxcblx0XHRcdGNoZWNrO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjaGVjayA9IHJlc1tpXTtcblx0XHRcdGlmIChjaGVjay5zZW50ID09PSB0cnVlICYmIGNoZWNrLnN0YXR1cyA9PT0gdHJ1ZSlcblx0XHRcdFx0dmFsaWRzLnB1c2goY2hlY2spO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpbnZhbGlkcy5wdXNoKGNoZWNrKTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbGlkczogdmFsaWRzLFxuXHRcdFx0aW52YWxpZHM6IGludmFsaWRzXG5cdFx0fTtcblx0fTtcblxuXHRycGMucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocCkge1xuXHRcdGlmIChwLnNlbnQgPT09IHRydWUgJiYgcC5zdGF0dXMgPT09IHRydWUpXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHAucmVzcG9uc2UpO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChwLnJlc3BvbnNlKTtcblx0fTtcblx0cnBjLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gKHApIHtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHBbaV0uc2VudCA9PT0gZmFsc2UgfHwgcFtpXS5zdGF0dXMgPT09IGZhbHNlKVxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QocCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShwKTtcblx0fTtcblx0cnBjLnByb3RvdHlwZS5yZXNvbHZlQXRMZWFzdE9uZSA9IGZ1bmN0aW9uIChwKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChwW2ldLnNlbnQgPT09IHRydWUgJiYgcFtpXS5zdGF0dXMgPT09IHRydWUpXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHApO1xuXHR9O1xuXG5cblxuXG5cdHJldHVybiBycGM7XG5cbn07XG4iXX0="}